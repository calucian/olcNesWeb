/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app.js":
/*!****************!*\
  !*** ./app.js ***!
  \****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_Bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/Bus */ \"./src/Bus.js\");\n/* harmony import */ var _src_Cartridge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Cartridge */ \"./src/Cartridge.js\");\n/* harmony import */ var _src_Cpu6502__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/Cpu6502 */ \"./src/Cpu6502.js\");\n/* harmony import */ var _src_olc2C02__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/olc2C02 */ \"./src/olc2C02.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar App = /*#__PURE__*/function () {\n  function App(displayCanvas, debugCanvas) {\n    var _this = this;\n\n    _classCallCheck(this, App);\n\n    this.displayCanvas = displayCanvas;\n    this.debugCanvas = debugCanvas;\n    this.nes = new _src_Bus__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.ppu = new _src_olc2C02__WEBPACK_IMPORTED_MODULE_3__[\"default\"](displayCanvas);\n    this.cpu = new _src_Cpu6502__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    this.cpu.ConnectBus(this.nes);\n    this.ppu.ConnectBus(this.nes);\n    this.cartridge = new _src_Cartridge__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    this.bEmulationRun = false;\n    this.fElapsedTime = 0;\n    this.fResidualTime = 0;\n    this.mapAsm = [];\n    this.keys = {\n      a: false,\n      b: false,\n      select: false,\n      start: false,\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n    this.keyMapping = {\n      x: 'a',\n      z: 'b',\n      s: 'start',\n      a: 'select',\n      ArrowUp: 'up',\n      ArrowDown: 'down',\n      ArrowLeft: 'left',\n      ArrowRight: 'right'\n    };\n    window.addEventListener(\"keydown\", function (event) {\n      if (_this.keyMapping[event.key]) {\n        _this.keys[_this.keyMapping[event.key]] = true;\n        event.preventDefault();\n      }\n    }, true);\n    window.addEventListener(\"keyup\", function (event) {\n      if (_this.keyMapping[event.key]) {\n        _this.keys[_this.keyMapping[event.key]] = false;\n        event.preventDefault();\n      }\n    }, true); // Just JS things!\n\n    this.step = this.step.bind(this);\n  }\n\n  _createClass(App, [{\n    key: \"hex\",\n    value: function hex(n, d) {\n      var s = [];\n\n      for (var i = d - 1; i >= 0; i--, n >>= 4) {\n        s[i] = \"0123456789ABCDEF\"[n & 0xF];\n      }\n\n      return s.join('');\n    }\n  }, {\n    key: \"DrawString\",\n    value: function DrawString(x, y, string, color) {\n      this.debugCanvas.fillStyle = color || '#FFFFFF';\n      this.debugCanvas.fillText(string, x, y);\n    }\n  }, {\n    key: \"DrawRect\",\n    value: function DrawRect(x, y, w, h, color) {\n      if (color instanceof Pixel) {\n        this.debugCanvas.fillStyle = color.getCode();\n      } else this.debugCanvas.fillStyle = color || '#FFFFFF';\n\n      this.debugCanvas.fillRect(x, y, w, h);\n    }\n  }, {\n    key: \"DrawCpu\",\n    value: function DrawCpu(x, y) {\n      var status = \"STATUS: \";\n      this.DrawString(x + 64, y, \"N\", this.nes.cpu.GetFlag(_src_Cpu6502__WEBPACK_IMPORTED_MODULE_2__[\"default\"].FLAGS6502.N) ? '#00FF00' : '#FF0000');\n      this.DrawString(x + 80, y, \"V\", this.nes.cpu.GetFlag(_src_Cpu6502__WEBPACK_IMPORTED_MODULE_2__[\"default\"].FLAGS6502.V) ? '#00FF00' : '#FF0000');\n      this.DrawString(x + 96, y, \"-\", this.nes.cpu.GetFlag(_src_Cpu6502__WEBPACK_IMPORTED_MODULE_2__[\"default\"].FLAGS6502.U) ? '#00FF00' : '#FF0000');\n      this.DrawString(x + 112, y, \"B\", this.nes.cpu.GetFlag(_src_Cpu6502__WEBPACK_IMPORTED_MODULE_2__[\"default\"].FLAGS6502.B) ? '#00FF00' : '#FF0000');\n      this.DrawString(x + 128, y, \"D\", this.nes.cpu.GetFlag(_src_Cpu6502__WEBPACK_IMPORTED_MODULE_2__[\"default\"].FLAGS6502.D) ? '#00FF00' : '#FF0000');\n      this.DrawString(x + 144, y, \"I\", this.nes.cpu.GetFlag(_src_Cpu6502__WEBPACK_IMPORTED_MODULE_2__[\"default\"].FLAGS6502.I) ? '#00FF00' : '#FF0000');\n      this.DrawString(x + 160, y, \"Z\", this.nes.cpu.GetFlag(_src_Cpu6502__WEBPACK_IMPORTED_MODULE_2__[\"default\"].FLAGS6502.Z) ? '#00FF00' : '#FF0000');\n      this.DrawString(x + 178, y, \"C\", this.nes.cpu.GetFlag(_src_Cpu6502__WEBPACK_IMPORTED_MODULE_2__[\"default\"].FLAGS6502.C) ? '#00FF00' : '#FF0000');\n      this.DrawString(x, y + 10, \"PC: $\" + this.hex(this.nes.cpu.pc, 4));\n      this.DrawString(x, y + 20, \"A: $\" + this.hex(this.nes.cpu.a || this.nes.cpu.A, 2) + \"  [\" + this.nes.cpu.a + \"]\");\n      this.DrawString(x, y + 30, \"X: $\" + this.hex(this.nes.cpu.x || this.nes.cpu.X, 2) + \"  [\" + this.nes.cpu.x + \"]\");\n      this.DrawString(x, y + 40, \"Y: $\" + this.hex(this.nes.cpu.y || this.nes.cpu.Y, 2) + \"  [\" + this.nes.cpu.y + \"]\");\n      this.DrawString(x, y + 50, \"Stack P: $\" + this.hex(this.nes.cpu.stkp, 4));\n    }\n  }, {\n    key: \"DrawCode\",\n    value: function DrawCode(x, y, nLines) {\n      var it_a = this.nes.cpu.pc;\n      var nLineY = (nLines >> 1) * 10 + y;\n\n      if (it_a !== this.mapAsm.length) {\n        this.DrawString(x, nLineY, this.mapAsm[it_a], '#FF0000');\n\n        while (nLineY < nLines * 10 + y && it_a < mapAsm.length) {\n          if (++it_a !== this.mapAsm.length && this.mapAsm[it_a]) {\n            nLineY += 10;\n            this.DrawString(x, nLineY, this.mapAsm[it_a]);\n          }\n        }\n      }\n\n      it_a = this.nes.cpu.pc;\n      nLineY = (nLines >> 1) * 10 + y;\n\n      if (it_a !== this.mapAsm.length) {\n        while (nLineY > y && it_a > 0) {\n          if (--it_a !== this.mapAsm.length && this.mapAsm[it_a]) {\n            nLineY -= 10;\n            this.DrawString(x, nLineY, this.mapAsm[it_a]);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"handleFile\",\n    value: function handleFile(file) {\n      var _this2 = this;\n\n      this.cartridge.loadFile(file, function () {\n        _this2.nes.insertCartridge(_this2.cartridge);\n\n        _this2.nes.reset();\n\n        _this2.mapAsm = _this2.nes.cpu.disassemble(0x0000, 0xFFFF);\n      });\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.bEmulationRun = !this.bEmulationRun;\n      this.step();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.nes.reset();\n    }\n  }, {\n    key: \"stepLine\",\n    value: function stepLine() {\n      do {\n        this.nes.clock();\n      } while (!this.nes.cpu.complete());\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      this.debugCanvas.fillStyle = '#000099';\n      this.debugCanvas.fillRect(0, 0, 500, 500);\n      this.DrawCpu(0, 50);\n      this.DrawCode(200, 72, 26); // Draw OAM Contents (first 26 out of 64) ======================================\n\n      for (var i = 0; i < 26; i++) {\n        var s = this.hex(i, 2) + \": (\" + this.nes.ppu.OAM[i].x + \", \" + this.nes.ppu.OAM[i].y + \") \" + \"ID: \" + hex(this.nes.ppu.OAM[i].id, 2) + \" AT: \" + hex(this.nes.ppu.OAM[i].attribute, 2);\n        this.DrawString(0, 172 + i * 10, s);\n      } // Draw Palettes & Pattern Tables ==============================================\n\n\n      var nSwatchSize = 8;\n      var nSelectedPalette = 0; //DrawRect(20 + nSelectedPalette * (nSwatchSize * 5) - 1, 20, (nSwatchSize * 4), nSwatchSize, '#ffffff');\n\n      for (var p = 0; p < 8; p++) {\n        // For each palette\n        for (var _s = 0; _s < 4; _s++) {\n          // For each index\n          this.DrawRect(20 + p * (nSwatchSize * 5) + _s * nSwatchSize, 20, nSwatchSize, nSwatchSize, this.ppu.GetColourFromPaletteRam(p, _s));\n        }\n      } // Draw selection reticule around selected palette\n      // Generate Pattern Tables\n\n\n      this.debugCanvas.putImageData(this.ppu.GetPatternTable(0, nSelectedPalette).ctx, 150, 360);\n      this.debugCanvas.putImageData(this.ppu.GetPatternTable(1, nSelectedPalette).ctx, 300, 360); // Draw rendered output ========================================================\n    }\n  }, {\n    key: \"step\",\n    value: function step() {\n      var n = Date.now();\n\n      if (!this.nes.cart) {\n        setTimeout(this.step, 1000 / 24);\n        return;\n      } // Handle input for controller in port #1\n\n\n      this.nes.controller[0] = 0x00;\n      this.nes.controller[0] |= this.keys.a ? 0x80 : 0x00; // A Button\n\n      this.nes.controller[0] |= this.keys.b ? 0x40 : 0x00; // B Button\n\n      this.nes.controller[0] |= this.keys.select ? 0x20 : 0x00; // Select\n\n      this.nes.controller[0] |= this.keys.start ? 0x10 : 0x00; // Start\n\n      this.nes.controller[0] |= this.keys.up ? 0x08 : 0x00;\n      this.nes.controller[0] |= this.keys.down ? 0x04 : 0x00;\n      this.nes.controller[0] |= this.keys.left ? 0x02 : 0x00;\n      this.nes.controller[0] |= this.keys.right ? 0x01 : 0x00;\n      this.fElapsedTime++;\n\n      if (this.bEmulationRun) {\n        do {\n          this.nes.clock();\n        } while (!this.nes.ppu.frame_complete); //do { nes.clock(); } while (nes.ppu.cycle !== -1);\n\n\n        this.nes.ppu.frame_complete = false;\n        if (this.fResidualTime > 0.0) this.fResidualTime -= this.fElapsedTime;else {\n          this.fResidualTime += 1.0 / 60.0 - this.fElapsedTime;\n        }\n      }\n\n      this.displayCanvas.putImageData(this.nes.ppu.GetScreen().ctx, 0, 0); //setTimeout(this.step, (20 - (Date.now() - n)));\n\n      return true;\n    }\n  }]);\n\n  return App;\n}();\n\nwindow.App = App;\n\n//# sourceURL=webpack:///./app.js?");

/***/ }),

/***/ "./src/Bus.js":
/*!********************!*\
  !*** ./src/Bus.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n\tolc::NES - System Bus\n\t\"Thanks Dad for believing computers were gonna be a big deal...\" - javidx9\n\n\tLicense (OLC-3)\n\t~~~~~~~~~~~~~~~\n\n\tCopyright 2018-2019 OneLoneCoder.com\n\n\tRedistribution and use in source and binary forms, with or without\n\tmodification, are permitted provided that the following conditions\n\tare met:\n\n\t1. Redistributions or derivations of source code must retain the above\n\tcopyright notice, this list of conditions and the following disclaimer.\n\n\t2. Redistributions or derivative works in binary form must reproduce\n\tthe above copyright notice. This list of conditions and the following\n\tdisclaimer must be reproduced in the documentation and/or other\n\tmaterials provided with the distribution.\n\n\t3. Neither the name of the copyright holder nor the names of its\n\tcontributors may be used to endorse or promote products derived\n\tfrom this software without specific prior written permission.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\tLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\tA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\tHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\tSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\tLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\tDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\tTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\tOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\tRelevant Video: https://youtu.be/xdzOvpYPmGE\n\n\tLinks\n\t~~~~~\n\tYouTube:\thttps://www.youtube.com/javidx9\n\t\t\t\thttps://www.youtube.com/javidx9extra\n\tDiscord:\thttps://discord.gg/WhwHUMV\n\tTwitter:\thttps://www.twitter.com/javidx9\n\tTwitch:\t\thttps://www.twitch.tv/javidx9\n\tGitHub:\t\thttps://www.github.com/onelonecoder\n\tPatreon:\thttps://www.patreon.com/javidx9\n\tHomepage:\thttps://www.onelonecoder.com\n\n\tAuthor\n\t~~~~~~\n\tDavid Barr, aka javidx9, �OneLoneCoder 2019\n*/\nvar Bus = /*#__PURE__*/function () {\n  function Bus(cpu, ppu, apu) {\n    _classCallCheck(this, Bus);\n\n    this.cpu = cpu; // The 2C02 Picture Processing Unit\n\n    this.ppu = ppu;\n    this.apu = apu; // The Cartridge or \"GamePak\"\n\n    this.cart = null; // 2KB of RAM\n\n    this.cpuRam = Array(2048).fill(0x00); // Controllers\n\n    this.controller = [];\n    this.nSystemClockCounter = 0;\n    this.controller_state = [];\n    this.dma_page = 0x00;\n    this._dma_addr = 0x00;\n    this.dma_data = 0x00;\n    this.dma_dummy = true;\n    this.dma_transfer = false;\n    this.audioTimePerNESClock = 0;\n    this.audioTimePerSystemSample = 0;\n    this.audioTime = 0;\n  }\n\n  _createClass(Bus, [{\n    key: \"cpuWrite\",\n    value: function cpuWrite(addr, data) {\n      if (this.cart.cpuWrite(addr, data) !== false) {// The cartridge \"sees all\" and has the facility to veto\n        // the propagation of the bus transaction if it requires.\n        // This allows the cartridge to map any address to some\n        // other data, including the facility to divert transactions\n        // with other physical devices. The NES does not do this\n        // but I figured it might be quite a flexible way of adding\n        // \"custom\" hardware to the NES in the future!\n      } else if (addr >= 0x0000 && addr <= 0x1FFF) {\n        // System RAM Address Range. The range covers 8KB, though\n        // there is only 2KB available. That 2KB is \"mirrored\"\n        // the bottom 11 bits is the same as addr % 2048.\n        // through this address range. Using bitwise AND to mask\n        this.cpuRam[addr & 0x07FF] = data;\n      } else if (addr >= 0x2000 && addr <= 0x3FFF) {\n        // PPU Address range. The PPU only has 8 primary registers\n        // and these are repeated throughout this range. We can\n        // use bitwise AND operation to mask the bottom 3 bits,\n        // which is the equivalent of addr % 8.\n        this.ppu.cpuWrite(addr & 0x0007, data);\n      } else if (addr >= 0x4000 && addr <= 0x4013 || addr === 0x4015 || addr === 0x4017) {\n        this.apu.cpuWrite(addr, data);\n      } else if (addr === 0x4014) {\n        // A write to this address initiates a DMA transfer\n        this.dma_page = data;\n        this.dma_addr = 0x00;\n        this.dma_transfer = true;\n      } else if (addr >= 0x4016 && addr <= 0x4017) {\n        // \"Lock In\" controller state at this time\n        this.controller_state[addr & 0x0001] = this.controller[addr & 0x0001];\n      }\n    }\n  }, {\n    key: \"insertCartridge\",\n    value: function insertCartridge(cartridge) {\n      // Connects cartridge to both Main Bus and CPU Bus\n      this.cart = cartridge;\n      this.ppu.ConnectCartridge(cartridge);\n    }\n  }, {\n    key: \"cpuRead\",\n    value: function cpuRead(addr, bReadOnly) {\n      var data = 0x00;\n      var temp = this.cart.cpuRead(addr, data);\n\n      if (temp !== false) {\n        data = temp; // Cartridge Address Range\n      } else if (addr >= 0x0000 && addr <= 0x1FFF) {\n        // System RAM Address Range, mirrored every 2048\n        data = this.cpuRam[addr & 0x07FF];\n      } else if (addr >= 0x2000 && addr <= 0x3FFF) {\n        // PPU Address range, mirrored every 8\n        data = this.ppu.cpuRead(addr & 0x0007, bReadOnly);\n      } else if (addr >= 0x4016 && addr <= 0x4017) {\n        // Read out the MSB of the controller status word\n        data = (this.controller_state[addr & 0x0001] & 0x80) > 0;\n        this.controller_state[addr & 0x0001] <<= 1;\n      }\n\n      return data;\n    }\n  }, {\n    key: \"setSampleFrequency\",\n    value: function setSampleFrequency(sample_rate) {\n      this.audioTimePerSystemSample = 1000 / sample_rate;\n      this.audioTimePerNESClock = 0.000186243393;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.cart.reset();\n      this.cpu.reset();\n      this.ppu.reset();\n      this.nSystemClockCounter = 0;\n      this.dma_page = 0x00;\n      this.dma_addr = 0x00;\n      this.dma_data = 0x00;\n      this.dma_dummy = true;\n      this.dma_transfer = false;\n    }\n  }, {\n    key: \"clock\",\n    value: function clock() {\n      // Clocking. The heart and soul of an emulator. The running\n      // frequency is controlled by whatever calls this function.\n      // So here we \"divide\" the clock as necessary and call\n      // the peripheral devices clock() function at the correct\n      // times.\n      // The fastest clock frequency the digital system cares\n      // about is equivalent to the PPU clock. So the PPU is clocked\n      // each time this function is called.\n      this.ppu.clock(); //this.apu.clock();\n      // The CPU runs 3 times slower than the PPU so we only call its\n      // clock() function every 3 times this function is called. We\n      // have a global counter to keep track of this.\n\n      if (this.nSystemClockCounter % 3 === 0) {\n        // Is the system performing a DMA transfer form CPU memory to\n        // OAM memory on PPU?...\n        if (this.dma_transfer) {\n          // ...Yes! We need to wait until the next even CPU clock cycle\n          // before it starts...\n          if (this.dma_dummy) {\n            // ...So hang around in here each clock until 1 or 2 cycles\n            // have elapsed...\n            if (this.nSystemClockCounter % 2 === 1) {\n              // ...and finally allow DMA to start\n              this.dma_dummy = false;\n            }\n          } else {\n            // DMA can take place!\n            if (this.nSystemClockCounter % 2 === 0) {\n              // On even clock cycles, read from CPU bus\n              this.dma_data = this.cpuRead(this.dma_page << 8 | this.dma_addr);\n            } else {\n              // On odd clock cycles, write to PPU OAM\n              this.ppu.OAMWrite(this.dma_addr, this.dma_data); // Increment the lo byte of the address\n\n              this.dma_addr++; // If this wraps around, we know that 256\n              // bytes have been written, so end the DMA\n              // transfer, and proceed as normal\n\n              if (this.dma_addr === 0x00) {\n                this.dma_transfer = false;\n                this.dma_dummy = true;\n              }\n            }\n          }\n        } else {\n          // No DMA happening, the CPU is in control of its\n          // own destiny. Go forth my friend and calculate\n          // awesomeness for many generations to come...\n          this.cpu.clock();\n        }\n      }\n      /*let audioSampleReady = false;\n      this.audioTime += this.audioTimePerNESClock;\n      if (this.audioTime >= this.audioTimePerSystemSample) {\n      \tthis.audioTime -= this.audioTimePerSystemSample;\n      \tthis.audioSample = {...this.apu.pulse1_osc};\n      \t\taudioSampleReady = true;\n      }*/\n      // The PPU is capable of emitting an interrupt to indicate the\n      // vertical blanking period has been entered. If it has, we need\n      // to send that irq to the CPU.\n\n\n      if (this.ppu.nmi) {\n        this.ppu.nmi = false;\n        this.cpu.nmi();\n      }\n\n      this.nSystemClockCounter++; //return audioSampleReady;\n    }\n  }, {\n    key: \"dma_addr\",\n    set: function set(value) {\n      this._dma_addr = value & 0xFF;\n    },\n    get: function get() {\n      return this._dma_addr;\n    }\n  }]);\n\n  return Bus;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Bus);\n\n//# sourceURL=webpack:///./src/Bus.js?");

/***/ }),

/***/ "./src/Cartridge.js":
/*!**************************!*\
  !*** ./src/Cartridge.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mappers_Mapper000__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mappers/Mapper000 */ \"./src/mappers/Mapper000.js\");\n/* harmony import */ var _mappers_Mapper001__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mappers/Mapper001 */ \"./src/mappers/Mapper001.js\");\n/* harmony import */ var _mappers_Mapper002__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mappers/Mapper002 */ \"./src/mappers/Mapper002.js\");\n/* harmony import */ var _lib_parseNes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/parseNes */ \"./src/lib/parseNes.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n\tolc::NES - Cartridge\n\t\"Thanks Dad for believing computers were gonna be a big deal...\" - javidx9\n\n\tLicense (OLC-3)\n\t~~~~~~~~~~~~~~~\n\n\tCopyright 2018-2019 OneLoneCoder.com\n\n\tRedistribution and use in source and binary forms, with or without\n\tmodification, are permitted provided that the following conditions\n\tare met:\n\n\t1. Redistributions or derivations of source code must retain the above\n\tcopyright notice, this list of conditions and the following disclaimer.\n\n\t2. Redistributions or derivative works in binary form must reproduce\n\tthe above copyright notice. This list of conditions and the following\n\tdisclaimer must be reproduced in the documentation and/or other\n\tmaterials provided with the distribution.\n\n\t3. Neither the name of the copyright holder nor the names of its\n\tcontributors may be used to endorse or promote products derived\n\tfrom this software without specific prior written permission.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\tLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\tA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\tHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\tSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\tLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\tDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\tTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\tOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\tRelevant Video: https://youtu.be/-THeUXqR3zY\n\n\tLinks\n\t~~~~~\n\tYouTube:\thttps://www.youtube.com/javidx9\n\t\t\t\thttps://www.youtube.com/javidx9extra\n\tDiscord:\thttps://discord.gg/WhwHUMV\n\tTwitter:\thttps://www.twitter.com/javidx9\n\tTwitch:\t\thttps://www.twitch.tv/javidx9\n\tGitHub:\t\thttps://www.github.com/onelonecoder\n\tPatreon:\thttps://www.patreon.com/javidx9\n\tHomepage:\thttps://www.onelonecoder.com\n\n\tAuthor\n\t~~~~~~\n\tDavid Barr, aka javidx9, �OneLoneCoder 2019\n*/\n\n\n\n\n\nvar Cartridge = /*#__PURE__*/function () {\n  function Cartridge() {\n    _classCallCheck(this, Cartridge);\n\n    this.mirror = self.HORIZONTAL;\n    this.nMapperID = 0;\n    this.nPRGBanks = 0;\n    this.nCHRBanks = 0;\n    this.vPRGMemory = [];\n    this.vCHRMemory = [];\n    this.pMapper = null;\n    this.bImageValid = false;\n  }\n\n  _createClass(Cartridge, [{\n    key: \"loadFile\",\n    value: function loadFile(file, cb) {\n      var _this = this;\n\n      var reader = new FileReader();\n\n      reader.onload = function (data) {\n        var info = Object(_lib_parseNes__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(new buffer.Buffer(data.target.result));\n        _this.vPRGMemory = info.prg_rom;\n        if (info.chr_rom_size) _this.vCHRMemory = info.chr_rom;\n        var mirroring = {\n          'horizontal': 1,\n          'vertical': 2,\n          'vcertical': 3,\n          'vecertical': 4\n        };\n        _this.mirror = mirroring[info.mirroring];\n        _this.info = info;\n        _this.nPRGBanks = info.prg_rom_size / 16384;\n        _this.nCHRBanks = info.chr_rom_size / 8192; // Load appropriate mapper\n\n        switch (info.mapper) {\n          case 0:\n            _this.pMapper = new _mappers_Mapper000__WEBPACK_IMPORTED_MODULE_0__[\"default\"](_this.nPRGBanks, _this.nCHRBanks);\n            break;\n\n          case 1:\n            _this.pMapper = new _mappers_Mapper001__WEBPACK_IMPORTED_MODULE_1__[\"default\"](_this.nPRGBanks, _this.nCHRBanks, _this.mirror);\n            break;\n\n          case 2:\n            _this.pMapper = new _mappers_Mapper002__WEBPACK_IMPORTED_MODULE_2__[\"default\"](_this.nPRGBanks, _this.nCHRBanks);\n            break;\n        }\n\n        cb();\n        _this.bImageValid = true;\n      };\n\n      reader.readAsArrayBuffer(file);\n    }\n  }, {\n    key: \"ImageValid\",\n    value: function ImageValid() {\n      return this.bImageValid;\n    }\n    /**\n     * @TODO: fix how data is passed\n     */\n\n  }, {\n    key: \"cpuRead\",\n    value: function cpuRead(addr) {\n      var data = {\n        data: null\n      };\n      var mapped_addr = this.pMapper.cpuMapRead(addr, data);\n\n      if (mapped_addr !== false) {\n        if (mapped_addr === 0xFFFFFFFF) {\n          return data.data;\n        }\n\n        return this.vPRGMemory[mapped_addr];\n      }\n\n      return false;\n    }\n  }, {\n    key: \"cpuWrite\",\n    value: function cpuWrite(addr, data) {\n      var mapped_addr = this.pMapper.cpuMapWrite(addr, data);\n\n      if (mapped_addr !== false) {\n        this.vPRGMemory[mapped_addr] = data;\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ppuRead\",\n    value: function ppuRead(addr) {\n      var mapped_addr = this.pMapper.ppuMapRead(addr);\n\n      if (mapped_addr !== false) {\n        return this.vCHRMemory[mapped_addr];\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ppuWrite\",\n    value: function ppuWrite(addr, data) {\n      var mapped_addr = this.pMapper.ppuMapWrite(addr, data);\n\n      if (mapped_addr !== false) {\n        this.vCHRMemory[mapped_addr] = data;\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.pMapper) {\n        this.pMapper.reset();\n      }\n    }\n  }]);\n\n  return Cartridge;\n}();\n\nCartridge.HORIZONTAL = 1;\nCartridge.VERTICAL = 2;\nCartridge.ONESCREEN_LO = 3;\nCartridge.ONESCREEN_HI = 4;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Cartridge);\n\n//# sourceURL=webpack:///./src/Cartridge.js?");

/***/ }),

/***/ "./src/Cpu6502.js":
/*!************************!*\
  !*** ./src/Cpu6502.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * A 6502 processor emulator\n *\n * This is not the CPU that Javidx built as I could not get\n * the code to work well in javascript\n * Original source code: https://github.com/ScullinSteel/cpu6502\n */\nvar Cpu6502 = /*#__PURE__*/function () {\n  function Cpu6502() {\n    _classCallCheck(this, Cpu6502);\n\n    this.pc = 0; // Program counter\n\n    this.A = 0;\n    this.X = 0;\n    this.Y = 0;\n    this.S = 0; // Registers\n\n    this.N = 0;\n    this.Z = 1;\n    this.C = 0;\n    this.V = 0; // ALU flags\n\n    this.I = 0;\n    this.D = 0; // Other flags\n    // IRQ lines\n\n    this.tmp = 0;\n    this.addr = 0; // Temporary registers\n\n    this.opcode = 0; // Current opcode\n\n    this.cycles = 0; // Cycles counter\n\n    this.clock_count = 0;\n    this.lookup = [];\n    /*  BRK     */\n\n    this.lookup[0x00] = [this.imp, this.brk];\n    /*  ORA izx */\n\n    this.lookup[0x01] = [this.izx, this.ora];\n    /* *KIL     */\n\n    this.lookup[0x02] = [this.imp, this.kil];\n    /* *SLO izx */\n\n    this.lookup[0x03] = [this.izx, this.slo, this.rmw];\n    /* *NOP zp  */\n\n    this.lookup[0x04] = [this.zp, this.nop];\n    /*  ORA zp  */\n\n    this.lookup[0x05] = [this.zp, this.ora];\n    /*  ASL zp  */\n\n    this.lookup[0x06] = [this.zp, this.asl, this.rmw];\n    /* *SLO zp  */\n\n    this.lookup[0x07] = [this.zp, this.slo, this.rmw];\n    /*  PHP     */\n\n    this.lookup[0x08] = [this.imp, this.php];\n    /*  ORA imm */\n\n    this.lookup[0x09] = [this.imm, this.ora];\n    /*  ASL     */\n\n    this.lookup[0x0A] = [this.imp, this.asla];\n    /* *ANC imm */\n\n    this.lookup[0x0B] = [this.imm, this.anc];\n    /* *NOP abs */\n\n    this.lookup[0x0C] = [this.abs, this.nop];\n    /*  ORA abs */\n\n    this.lookup[0x0D] = [this.abs, this.ora];\n    /*  ASL abs */\n\n    this.lookup[0x0E] = [this.abs, this.asl, this.rmw];\n    /* *SLO abs */\n\n    this.lookup[0x0F] = [this.abs, this.slo, this.rmw];\n    /*  BPL rel */\n\n    this.lookup[0x10] = [this.rel, this.bpl];\n    /*  ORA izy */\n\n    this.lookup[0x11] = [this.izy, this.ora];\n    /* *KIL     */\n\n    this.lookup[0x12] = [this.imp, this.kil];\n    /* *SLO izy */\n\n    this.lookup[0x13] = [this.izy, this.slo, this.rmw];\n    /* *NOP zpx */\n\n    this.lookup[0x14] = [this.zpx, this.nop];\n    /*  ORA zpx */\n\n    this.lookup[0x15] = [this.zpx, this.ora];\n    /*  ASL zpx */\n\n    this.lookup[0x16] = [this.zpx, this.asl, this.rmw];\n    /* *SLO zpx */\n\n    this.lookup[0x17] = [this.zpx, this.slo, this.rmw];\n    /*  CLC     */\n\n    this.lookup[0x18] = [this.imp, this.clc];\n    /*  ORA aby */\n\n    this.lookup[0x19] = [this.aby, this.ora];\n    /* *NOP     */\n\n    this.lookup[0x1A] = [this.imp, this.nop];\n    /* *SLO aby */\n\n    this.lookup[0x1B] = [this.aby, this.slo, this.rmw];\n    /* *NOP abx */\n\n    this.lookup[0x1C] = [this.abx, this.nop];\n    /*  ORA abx */\n\n    this.lookup[0x1D] = [this.abx, this.ora];\n    /*  ASL abx */\n\n    this.lookup[0x1E] = [this.abxp, this.asl, this.rmw];\n    /* *SLO abx */\n\n    this.lookup[0x1F] = [this.abx, this.slo, this.rmw];\n    /*  JSR abs */\n\n    this.lookup[0x20] = [this.abs, this.jsr];\n    /*  AND izx */\n\n    this.lookup[0x21] = [this.izx, this.and];\n    /* *KIL     */\n\n    this.lookup[0x22] = [this.imp, this.kil];\n    /* *RLA izx */\n\n    this.lookup[0x23] = [this.izx, this.rla, this.rmw];\n    /*  BIT zp  */\n\n    this.lookup[0x24] = [this.zp, this.bit];\n    /*  AND zp  */\n\n    this.lookup[0x25] = [this.zp, this.and];\n    /*  ROL zp  */\n\n    this.lookup[0x26] = [this.zp, this.rol, this.rmw];\n    /* *RLA zp  */\n\n    this.lookup[0x27] = [this.zp, this.rla, this.rmw];\n    /*  PLP     */\n\n    this.lookup[0x28] = [this.imp, this.plp];\n    /*  AND imm */\n\n    this.lookup[0x29] = [this.imm, this.and];\n    /*  ROL     */\n\n    this.lookup[0x2A] = [this.imp, this.rla];\n    /* *ANC imm */\n\n    this.lookup[0x2B] = [this.imm, this.anc];\n    /*  BIT abs */\n\n    this.lookup[0x2C] = [this.abs, this.bit];\n    /*  AND abs */\n\n    this.lookup[0x2D] = [this.abs, this.and];\n    /*  ROL abs */\n\n    this.lookup[0x2E] = [this.abs, this.rol, this.rmw];\n    /* *RLA abs */\n\n    this.lookup[0x2F] = [this.abs, this.rla, this.rmw];\n    /*  BMI rel */\n\n    this.lookup[0x30] = [this.rel, this.bmi];\n    /*  AND izy */\n\n    this.lookup[0x31] = [this.izy, this.and];\n    /* *KIL     */\n\n    this.lookup[0x32] = [this.imp, this.kil];\n    /* *RLA izy */\n\n    this.lookup[0x33] = [this.izy, this.rla, this.rmw];\n    /* *NOP zpx */\n\n    this.lookup[0x34] = [this.zpx, this.nop];\n    /*  AND zpx */\n\n    this.lookup[0x35] = [this.zpx, this.and];\n    /*  ROL zpx */\n\n    this.lookup[0x36] = [this.zpx, this.rol, this.rmw];\n    /* *RLA zpx */\n\n    this.lookup[0x37] = [this.zpx, this.rla, this.rmw];\n    /*  SEC     */\n\n    this.lookup[0x38] = [this.imp, this.sec];\n    /*  AND aby */\n\n    this.lookup[0x39] = [this.aby, this.and];\n    /* *NOP     */\n\n    this.lookup[0x3A] = [this.imp, this.nop];\n    /* *RLA aby */\n\n    this.lookup[0x3B] = [this.aby, this.rla, this.rmw];\n    /* *NOP abx */\n\n    this.lookup[0x3C] = [this.abx, this.nop];\n    /*  AND abx */\n\n    this.lookup[0x3D] = [this.abx, this.and];\n    /*  ROL abx */\n\n    this.lookup[0x3E] = [this.abxp, this.rol, this.rmw];\n    /* *RLA abx */\n\n    this.lookup[0x3F] = [this.abx, this.rla, this.rmw];\n    /*  RTI     */\n\n    this.lookup[0x40] = [this.imp, this.rti];\n    /*  EOR izx */\n\n    this.lookup[0x41] = [this.izx, this.eor];\n    /* *KIL     */\n\n    this.lookup[0x42] = [this.imp, this.kil];\n    /* *SRE izx */\n\n    this.lookup[0x43] = [this.izx, this.sre, this.rmw];\n    /* *NOP zp  */\n\n    this.lookup[0x44] = [this.zp, this.nop];\n    /*  EOR zp  */\n\n    this.lookup[0x45] = [this.zp, this.eor];\n    /*  LSR zp  */\n\n    this.lookup[0x46] = [this.zp, this.lsr, this.rmw];\n    /* *SRE zp  */\n\n    this.lookup[0x47] = [this.zp, this.sre, this.rmw];\n    /*  PHA     */\n\n    this.lookup[0x48] = [this.imp, this.pha];\n    /*  EOR imm */\n\n    this.lookup[0x49] = [this.imm, this.eor];\n    /*  LSR     */\n\n    this.lookup[0x4A] = [this.imp, this.lsra];\n    /* *ALR imm */\n\n    this.lookup[0x4B] = [this.imm, this.alr];\n    /*  JMP abs */\n\n    this.lookup[0x4C] = [this.abs, this.jmp];\n    /*  EOR abs */\n\n    this.lookup[0x4D] = [this.abs, this.eor];\n    /*  LSR abs */\n\n    this.lookup[0x4E] = [this.abs, this.lsr, this.rmw];\n    /* *SRE abs */\n\n    this.lookup[0x4F] = [this.abs, this.sre, this.rmw];\n    /*  BVC rel */\n\n    this.lookup[0x50] = [this.rel, this.bvc];\n    /*  EOR izy */\n\n    this.lookup[0x51] = [this.izy, this.eor];\n    /* *KIL     */\n\n    this.lookup[0x52] = [this.imp, this.kil];\n    /* *SRE izy */\n\n    this.lookup[0x53] = [this.izy, this.sre, this.rmw];\n    /* *NOP zpx */\n\n    this.lookup[0x54] = [this.zpx, this.nop];\n    /*  EOR zpx */\n\n    this.lookup[0x55] = [this.zpx, this.eor];\n    /*  LSR zpx */\n\n    this.lookup[0x56] = [this.zpx, this.lsr, this.rmw];\n    /* *SRE zpx */\n\n    this.lookup[0x57] = [this.zpx, this.sre, this.rmw];\n    /*  CLI     */\n\n    this.lookup[0x58] = [this.imp, this.cli];\n    /*  EOR aby */\n\n    this.lookup[0x59] = [this.aby, this.eor];\n    /* *NOP     */\n\n    this.lookup[0x5A] = [this.imp, this.nop];\n    /* *SRE aby */\n\n    this.lookup[0x5B] = [this.aby, this.sre, this.rmw];\n    /* *NOP abx */\n\n    this.lookup[0x5C] = [this.abx, this.nop];\n    /*  EOR abx */\n\n    this.lookup[0x5D] = [this.abx, this.eor];\n    /*  LSR abx */\n\n    this.lookup[0x5E] = [this.abxp, this.lsr, this.rmw];\n    /* *SRE abx */\n\n    this.lookup[0x5F] = [this.abx, this.sre, this.rmw];\n    /*  RTS     */\n\n    this.lookup[0x60] = [this.imp, this.rts];\n    /*  ADC izx */\n\n    this.lookup[0x61] = [this.izx, this.adc];\n    /* *KIL     */\n\n    this.lookup[0x62] = [this.imp, this.kil];\n    /* *RRA izx */\n\n    this.lookup[0x63] = [this.izx, this.rra, this.rmw];\n    /* *NOP zp  */\n\n    this.lookup[0x64] = [this.zp, this.nop];\n    /*  ADC zp  */\n\n    this.lookup[0x65] = [this.zp, this.adc];\n    /*  ROR zp  */\n\n    this.lookup[0x66] = [this.zp, this.ror, this.rmw];\n    /* *RRA zp  */\n\n    this.lookup[0x67] = [this.zp, this.rra, this.rmw];\n    /*  PLA     */\n\n    this.lookup[0x68] = [this.imp, this.pla];\n    /*  ADC imm */\n\n    this.lookup[0x69] = [this.imm, this.adc];\n    /*  ROR     */\n\n    this.lookup[0x6A] = [this.imp, this.rra];\n    /* *ARR imm */\n\n    this.lookup[0x6B] = [this.imm, this.arr];\n    /*  JMP ind */\n\n    this.lookup[0x6C] = [this.ind, this.jmp];\n    /*  ADC abs */\n\n    this.lookup[0x6D] = [this.abs, this.adc];\n    /*  ROR abs */\n\n    this.lookup[0x6E] = [this.abs, this.ror, this.rmw];\n    /* *RRA abs */\n\n    this.lookup[0x6F] = [this.abs, this.rra, this.rmw];\n    /*  BVS rel */\n\n    this.lookup[0x70] = [this.rel, this.bvs];\n    /*  ADC izy */\n\n    this.lookup[0x71] = [this.izy, this.adc];\n    /* *KIL     */\n\n    this.lookup[0x72] = [this.imp, this.kil];\n    /* *RRA izy */\n\n    this.lookup[0x73] = [this.izy, this.rra, this.rmw];\n    /* *NOP zpx */\n\n    this.lookup[0x74] = [this.zpx, this.nop];\n    /*  ADC zpx */\n\n    this.lookup[0x75] = [this.zpx, this.adc];\n    /*  ROR zpx */\n\n    this.lookup[0x76] = [this.zpx, this.ror, this.rmw];\n    /* *RRA zpx */\n\n    this.lookup[0x77] = [this.zpx, this.rra, this.rmw];\n    /*  SEI     */\n\n    this.lookup[0x78] = [this.imp, this.sei];\n    /*  ADC aby */\n\n    this.lookup[0x79] = [this.aby, this.adc];\n    /* *NOP     */\n\n    this.lookup[0x7A] = [this.imp, this.nop];\n    /* *RRA aby */\n\n    this.lookup[0x7B] = [this.aby, this.rra, this.rmw];\n    /* *NOP abx */\n\n    this.lookup[0x7C] = [this.abx, this.nop];\n    /*  ADC abx */\n\n    this.lookup[0x7D] = [this.abx, this.adc];\n    /*  ROR abx */\n\n    this.lookup[0x7E] = [this.abxp, this.ror, this.rmw];\n    /* *RRA abx */\n\n    this.lookup[0x7F] = [this.abx, this.rra, this.rmw];\n    /* *NOP imm */\n\n    this.lookup[0x80] = [this.imm, this.nop];\n    /*  STA izx */\n\n    this.lookup[0x81] = [this.izx, this.sta];\n    /* *NOP imm */\n\n    this.lookup[0x82] = [this.imm, this.nop];\n    /* *SAX izx */\n\n    this.lookup[0x83] = [this.izx, this.imp];\n    /*  STY zp  */\n\n    this.lookup[0x84] = [this.zp, this.sty];\n    /*  STA zp  */\n\n    this.lookup[0x85] = [this.zp, this.sta];\n    /*  STX zp  */\n\n    this.lookup[0x86] = [this.zp, this.stx];\n    /* *SAX zp  */\n\n    this.lookup[0x87] = [this.zp, this.imp];\n    /*  DEY     */\n\n    this.lookup[0x88] = [this.imp, this.dey];\n    /* *NOP imm */\n\n    this.lookup[0x89] = [this.imm, this.nop];\n    /*  TXA     */\n\n    this.lookup[0x8A] = [this.imp, this.txa];\n    /* *XAA imm */\n\n    this.lookup[0x8B] = [this.imm, this.imp];\n    /*  STY abs */\n\n    this.lookup[0x8C] = [this.abs, this.sty];\n    /*  STA abs */\n\n    this.lookup[0x8D] = [this.abs, this.sta];\n    /*  STX abs */\n\n    this.lookup[0x8E] = [this.abs, this.stx];\n    /* *SAX abs */\n\n    this.lookup[0x8F] = [this.abs, this.imp];\n    /*  BCC rel */\n\n    this.lookup[0x90] = [this.rel, this.bcc];\n    /*  STA izy */\n\n    this.lookup[0x91] = [this.izyp, this.sta];\n    /* *KIL     */\n\n    this.lookup[0x92] = [this.imp, this.kil];\n    /* *AHX izy */\n\n    this.lookup[0x93] = [this.izy, this.ahx];\n    /*  STY zpx */\n\n    this.lookup[0x94] = [this.zpx, this.sty];\n    /*  STA zpx */\n\n    this.lookup[0x95] = [this.zpx, this.sta];\n    /*  STX zpy */\n\n    this.lookup[0x96] = [this.zpy, this.stx];\n    /* *SAX zpy */\n\n    this.lookup[0x97] = [this.zpy, this.imp];\n    /*  TYA     */\n\n    this.lookup[0x98] = [this.imp, this.tya];\n    /*  STA aby */\n\n    this.lookup[0x99] = [this.abyp, this.sta];\n    /*  TXS     */\n\n    this.lookup[0x9A] = [this.imp, this.txs];\n    /* *TAS aby */\n\n    this.lookup[0x9B] = [this.aby, this.imp];\n    /* *SHY abx */\n\n    this.lookup[0x9C] = [this.abx, this.shy];\n    /*  STA abx */\n\n    this.lookup[0x9D] = [this.abxp, this.sta];\n    /* *SHX aby */\n\n    this.lookup[0x9E] = [this.aby, this.shx];\n    /* *AHX aby */\n\n    this.lookup[0x9F] = [this.aby, this.ahx];\n    /*  LDY imm */\n\n    this.lookup[0xA0] = [this.imm, this.ldy];\n    /*  LDA izx */\n\n    this.lookup[0xA1] = [this.izx, this.lda];\n    /*  LDX imm */\n\n    this.lookup[0xA2] = [this.imm, this.ldx];\n    /* *LAX izx */\n\n    this.lookup[0xA3] = [this.izx, this.lax];\n    /*  LDY zp  */\n\n    this.lookup[0xA4] = [this.zp, this.ldy];\n    /*  LDA zp  */\n\n    this.lookup[0xA5] = [this.zp, this.lda];\n    /*  LDX zp  */\n\n    this.lookup[0xA6] = [this.zp, this.ldx];\n    /* *LAX zp  */\n\n    this.lookup[0xA7] = [this.zp, this.lax];\n    /*  TAY     */\n\n    this.lookup[0xA8] = [this.imp, this.tay];\n    /*  LDA imm */\n\n    this.lookup[0xA9] = [this.imm, this.lda];\n    /*  TAX     */\n\n    this.lookup[0xAA] = [this.imp, this.tax];\n    /* *LAX imm */\n\n    this.lookup[0xAB] = [this.imm, this.lax];\n    /*  LDY abs */\n\n    this.lookup[0xAC] = [this.abs, this.ldy];\n    /*  LDA abs */\n\n    this.lookup[0xAD] = [this.abs, this.lda];\n    /*  LDX abs */\n\n    this.lookup[0xAE] = [this.abs, this.ldx];\n    /* *LAX abs */\n\n    this.lookup[0xAF] = [this.abs, this.lax];\n    /*  BCS rel */\n\n    this.lookup[0xB0] = [this.rel, this.bcs];\n    /*  LDA izy */\n\n    this.lookup[0xB1] = [this.izy, this.lda];\n    /* *KIL     */\n\n    this.lookup[0xB2] = [this.imp, this.kil];\n    /* *LAX izy */\n\n    this.lookup[0xB3] = [this.izy, this.lax];\n    /*  LDY zpx */\n\n    this.lookup[0xB4] = [this.zpx, this.ldy];\n    /*  LDA zpx */\n\n    this.lookup[0xB5] = [this.zpx, this.lda];\n    /*  LDX zpy */\n\n    this.lookup[0xB6] = [this.zpy, this.ldx];\n    /* *LAX zpy */\n\n    this.lookup[0xB7] = [this.zpy, this.lax];\n    /*  CLV     */\n\n    this.lookup[0xB8] = [this.imp, this.clv];\n    /*  LDA aby */\n\n    this.lookup[0xB9] = [this.aby, this.lda];\n    /*  TSX     */\n\n    this.lookup[0xBA] = [this.imp, this.tsx];\n    /* *LAS aby */\n\n    this.lookup[0xBB] = [this.aby, this.las];\n    /*  LDY abx */\n\n    this.lookup[0xBC] = [this.abx, this.ldy];\n    /*  LDA abx */\n\n    this.lookup[0xBD] = [this.abx, this.lda];\n    /*  LDX aby */\n\n    this.lookup[0xBE] = [this.aby, this.ldx];\n    /* *LAX aby */\n\n    this.lookup[0xBF] = [this.aby, this.lax];\n    /*  CPY imm */\n\n    this.lookup[0xC0] = [this.imm, this.cpy];\n    /*  CMP izx */\n\n    this.lookup[0xC1] = [this.izx, this.cmp];\n    /* *NOP imm */\n\n    this.lookup[0xC2] = [this.imm, this.nop];\n    /* *DCP izx */\n\n    this.lookup[0xC3] = [this.izx, this.dcp, this.rmw];\n    /*  CPY zp  */\n\n    this.lookup[0xC4] = [this.zp, this.cpy];\n    /*  CMP zp  */\n\n    this.lookup[0xC5] = [this.zp, this.cmp];\n    /*  DEC zp  */\n\n    this.lookup[0xC6] = [this.zp, this.dec, this.rmw];\n    /* *DCP zp  */\n\n    this.lookup[0xC7] = [this.zp, this.dcp, this.rmw];\n    /*  INY     */\n\n    this.lookup[0xC8] = [this.imp, this.iny];\n    /*  CMP imm */\n\n    this.lookup[0xC9] = [this.imm, this.cmp];\n    /*  DEX     */\n\n    this.lookup[0xCA] = [this.imp, this.dex];\n    /* *AXS imm */\n\n    this.lookup[0xCB] = [this.imm, this.axs];\n    /*  CPY abs */\n\n    this.lookup[0xCC] = [this.abs, this.cpy];\n    /*  CMP abs */\n\n    this.lookup[0xCD] = [this.abs, this.cmp];\n    /*  DEC abs */\n\n    this.lookup[0xCE] = [this.abs, this.dec, this.rmw];\n    /* *DCP abs */\n\n    this.lookup[0xCF] = [this.abs, this.dcp, this.rmw];\n    /*  BNE rel */\n\n    this.lookup[0xD0] = [this.rel, this.bne];\n    /*  CMP izy */\n\n    this.lookup[0xD1] = [this.izy, this.cmp];\n    /* *KIL     */\n\n    this.lookup[0xD2] = [this.imp, this.kil];\n    /* *DCP izy */\n\n    this.lookup[0xD3] = [this.izy, this.dcp, this.rmw];\n    /* *NOP zpx */\n\n    this.lookup[0xD4] = [this.zpx, this.nop];\n    /*  CMP zpx */\n\n    this.lookup[0xD5] = [this.zpx, this.cmp];\n    /*  DEC zpx */\n\n    this.lookup[0xD6] = [this.zpx, this.dec, this.rmw];\n    /* *DCP zpx */\n\n    this.lookup[0xD7] = [this.zpx, this.dcp, this.rmw];\n    /*  CLD     */\n\n    this.lookup[0xD8] = [this.imp, this.cld];\n    /*  CMP aby */\n\n    this.lookup[0xD9] = [this.aby, this.cmp];\n    /* *NOP     */\n\n    this.lookup[0xDA] = [this.imp, this.nop];\n    /* *DCP aby */\n\n    this.lookup[0xDB] = [this.aby, this.dcp, this.rmw];\n    /* *NOP abx */\n\n    this.lookup[0xDC] = [this.abx, this.nop];\n    /*  CMP abx */\n\n    this.lookup[0xDD] = [this.abx, this.cmp];\n    /*  DEC abx */\n\n    this.lookup[0xDE] = [this.abxp, this.dec, this.rmw];\n    /* *DCP abx */\n\n    this.lookup[0xDF] = [this.abx, this.dcp, this.rmw];\n    /*  CPX imm */\n\n    this.lookup[0xE0] = [this.imm, this.cpx];\n    /*  SBC izx */\n\n    this.lookup[0xE1] = [this.izx, this.sbc];\n    /* *NOP imm */\n\n    this.lookup[0xE2] = [this.imm, this.nop];\n    /* *ISC izx */\n\n    this.lookup[0xE3] = [this.izx, this.isc, this.rmw];\n    /*  CPX zp  */\n\n    this.lookup[0xE4] = [this.zp, this.cpx];\n    /*  SBC zp  */\n\n    this.lookup[0xE5] = [this.zp, this.sbc];\n    /*  INC zp  */\n\n    this.lookup[0xE6] = [this.zp, this.inc, this.rmw];\n    /* *ISC zp  */\n\n    this.lookup[0xE7] = [this.zp, this.isc, this.rmw];\n    /*  INX     */\n\n    this.lookup[0xE8] = [this.imp, this.inx];\n    /*  SBC imm */\n\n    this.lookup[0xE9] = [this.imm, this.sbc];\n    /*  NOP     */\n\n    this.lookup[0xEA] = [this.imp, this.nop];\n    /* *SBC imm */\n\n    this.lookup[0xEB] = [this.imm, this.sbc];\n    /*  CPX abs */\n\n    this.lookup[0xEC] = [this.abs, this.cpx];\n    /*  SBC abs */\n\n    this.lookup[0xED] = [this.abs, this.sbc];\n    /*  INC abs */\n\n    this.lookup[0xEE] = [this.abs, this.inc, this.rmw];\n    /* *ISC abs */\n\n    this.lookup[0xEF] = [this.abs, this.isc, this.rmw];\n    /*  BEQ rel */\n\n    this.lookup[0xF0] = [this.rel, this.beq];\n    /*  SBC izy */\n\n    this.lookup[0xF1] = [this.izy, this.sbc];\n    /* *KIL     */\n\n    this.lookup[0xF2] = [this.imp, this.kil];\n    /* *ISC izy */\n\n    this.lookup[0xF3] = [this.izy, this.isc, this.rmw];\n    /* *NOP zpx */\n\n    this.lookup[0xF4] = [this.zpx, this.nop];\n    /*  SBC zpx */\n\n    this.lookup[0xF5] = [this.zpx, this.sbc];\n    /*  INC zpx */\n\n    this.lookup[0xF6] = [this.zpx, this.inc, this.rmw];\n    /* *ISC zpx */\n\n    this.lookup[0xF7] = [this.zpx, this.isc, this.rmw];\n    /*  SED     */\n\n    this.lookup[0xF8] = [this.imp, this.sed];\n    /*  SBC aby */\n\n    this.lookup[0xF9] = [this.aby, this.sbc];\n    /* *NOP     */\n\n    this.lookup[0xFA] = [this.imp, this.nop];\n    /* *ISC aby */\n\n    this.lookup[0xFB] = [this.aby, this.isc, this.rmw];\n    /* *NOP abx */\n\n    this.lookup[0xFC] = [this.abx, this.nop];\n    /*  SBC abx */\n\n    this.lookup[0xFD] = [this.abx, this.sbc];\n    /*  INC abx */\n\n    this.lookup[0xFE] = [this.abxp, this.inc, this.rmw];\n    /* *ISC abx */\n\n    this.lookup[0xFF] = [this.abx, this.isc, this.rmw];\n    this.ASMlookup = [[\"brk\", this.brk, this.imm, 7], [\"ora\", this.ora, this.izx, 6], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"???\", this.nop, this.imp, 3], [\"ora\", this.ora, this.zp, 3], [\"asl\", this.asl, this.zp, 5], [\"???\", this.xxx, this.imp, 5], [\"php\", this.php, this.imp, 3], [\"ora\", this.ora, this.imm, 2], [\"asl\", this.asl, this.imp, 2], [\"???\", this.xxx, this.imp, 2], [\"???\", this.nop, this.imp, 4], [\"ora\", this.ora, this.abs, 4], [\"asl\", this.asl, this.abs, 6], [\"???\", this.xxx, this.imp, 6], [\"bpl\", this.bpl, this.rel, 2], [\"ora\", this.ora, this.izy, 5], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"???\", this.nop, this.imp, 4], [\"ora\", this.ora, this.zpx, 4], [\"asl\", this.asl, this.zpx, 6], [\"???\", this.xxx, this.imp, 6], [\"clc\", this.clc, this.imp, 2], [\"ora\", this.ora, this.aby, 4], [\"???\", this.nop, this.imp, 2], [\"???\", this.xxx, this.imp, 7], [\"???\", this.nop, this.imp, 4], [\"ora\", this.ora, this.abx, 4], [\"asl\", this.asl, this.abx, 7], [\"???\", this.xxx, this.imp, 7], [\"jsr\", this.jsr, this.abs, 6], [\"and\", this.and, this.izx, 6], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"bit\", this.bit, this.zp, 3], [\"and\", this.and, this.zp, 3], [\"rol\", this.rol, this.zp, 5], [\"???\", this.xxx, this.imp, 5], [\"plp\", this.plp, this.imp, 4], [\"and\", this.and, this.imm, 2], [\"rol\", this.rol, this.imp, 2], [\"???\", this.xxx, this.imp, 2], [\"bit\", this.bit, this.abs, 4], [\"and\", this.and, this.abs, 4], [\"rol\", this.rol, this.abs, 6], [\"???\", this.xxx, this.imp, 6], [\"bmi\", this.bmi, this.rel, 2], [\"and\", this.and, this.izy, 5], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"???\", this.nop, this.imp, 4], [\"and\", this.and, this.zpx, 4], [\"rol\", this.rol, this.zpx, 6], [\"???\", this.xxx, this.imp, 6], [\"sec\", this.sec, this.imp, 2], [\"and\", this.and, this.aby, 4], [\"???\", this.nop, this.imp, 2], [\"???\", this.xxx, this.imp, 7], [\"???\", this.nop, this.imp, 4], [\"and\", this.and, this.abx, 4], [\"rol\", this.rol, this.abx, 7], [\"???\", this.xxx, this.imp, 7], [\"rti\", this.rti, this.imp, 6], [\"eor\", this.eor, this.izx, 6], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"???\", this.nop, this.imp, 3], [\"eor\", this.eor, this.zp, 3], [\"lsr\", this.lsr, this.zp, 5], [\"???\", this.xxx, this.imp, 5], [\"pha\", this.pha, this.imp, 3], [\"eor\", this.eor, this.imm, 2], [\"lsr\", this.lsr, this.imp, 2], [\"???\", this.xxx, this.imp, 2], [\"jmp\", this.jmp, this.abs, 3], [\"eor\", this.eor, this.abs, 4], [\"lsr\", this.lsr, this.abs, 6], [\"???\", this.xxx, this.imp, 6], [\"bvc\", this.bvc, this.rel, 2], [\"eor\", this.eor, this.izy, 5], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"???\", this.nop, this.imp, 4], [\"eor\", this.eor, this.zpx, 4], [\"lsr\", this.lsr, this.zpx, 6], [\"???\", this.xxx, this.imp, 6], [\"cli\", this.cli, this.imp, 2], [\"eor\", this.eor, this.aby, 4], [\"???\", this.nop, this.imp, 2], [\"???\", this.xxx, this.imp, 7], [\"???\", this.nop, this.imp, 4], [\"eor\", this.eor, this.abx, 4], [\"lsr\", this.lsr, this.abx, 7], [\"???\", this.xxx, this.imp, 7], [\"rts\", this.rts, this.imp, 6], [\"adc\", this.adc, this.izx, 6], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"???\", this.nop, this.imp, 3], [\"adc\", this.adc, this.zp, 3], [\"ror\", this.ror, this.zp, 5], [\"???\", this.xxx, this.imp, 5], [\"pla\", this.pla, this.imp, 4], [\"adc\", this.adc, this.imm, 2], [\"ror\", this.ror, this.imp, 2], [\"???\", this.xxx, this.imp, 2], [\"jmp\", this.jmp, this.ind, 5], [\"adc\", this.adc, this.abs, 4], [\"ror\", this.ror, this.abs, 6], [\"???\", this.xxx, this.imp, 6], [\"bvs\", this.bvs, this.rel, 2], [\"adc\", this.adc, this.izy, 5], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"???\", this.nop, this.imp, 4], [\"adc\", this.adc, this.zpx, 4], [\"ror\", this.ror, this.zpx, 6], [\"???\", this.xxx, this.imp, 6], [\"sei\", this.sei, this.imp, 2], [\"adc\", this.adc, this.aby, 4], [\"???\", this.nop, this.imp, 2], [\"???\", this.xxx, this.imp, 7], [\"???\", this.nop, this.imp, 4], [\"adc\", this.adc, this.abx, 4], [\"ror\", this.ror, this.abx, 7], [\"???\", this.xxx, this.imp, 7], [\"???\", this.nop, this.imp, 2], [\"sta\", this.sta, this.izx, 6], [\"???\", this.nop, this.imp, 2], [\"???\", this.xxx, this.imp, 6], [\"sty\", this.sty, this.zp, 3], [\"sta\", this.sta, this.zp, 3], [\"stx\", this.stx, this.zp, 3], [\"???\", this.xxx, this.imp, 3], [\"dey\", this.dey, this.imp, 2], [\"???\", this.nop, this.imp, 2], [\"txa\", this.txa, this.imp, 2], [\"???\", this.xxx, this.imp, 2], [\"sty\", this.sty, this.abs, 4], [\"sta\", this.sta, this.abs, 4], [\"stx\", this.stx, this.abs, 4], [\"???\", this.xxx, this.imp, 4], [\"bcc\", this.bcc, this.rel, 2], [\"sta\", this.sta, this.izy, 6], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 6], [\"sty\", this.sty, this.zpx, 4], [\"sta\", this.sta, this.zpx, 4], [\"stx\", this.stx, this.zpy, 4], [\"???\", this.xxx, this.imp, 4], [\"tya\", this.tya, this.imp, 2], [\"sta\", this.sta, this.aby, 5], [\"txs\", this.txs, this.imp, 2], [\"???\", this.xxx, this.imp, 5], [\"???\", this.nop, this.imp, 5], [\"sta\", this.sta, this.abx, 5], [\"???\", this.xxx, this.imp, 5], [\"???\", this.xxx, this.imp, 5], [\"ldy\", this.ldy, this.imm, 2], [\"lda\", this.lda, this.izx, 6], [\"ldx\", this.ldx, this.imm, 2], [\"???\", this.xxx, this.imp, 6], [\"ldy\", this.ldy, this.zp, 3], [\"lda\", this.lda, this.zp, 3], [\"ldx\", this.ldx, this.zp, 3], [\"???\", this.xxx, this.imp, 3], [\"tay\", this.tay, this.imp, 2], [\"lda\", this.lda, this.imm, 2], [\"tax\", this.tax, this.imp, 2], [\"???\", this.xxx, this.imp, 2], [\"ldy\", this.ldy, this.abs, 4], [\"lda\", this.lda, this.abs, 4], [\"ldx\", this.ldx, this.abs, 4], [\"???\", this.xxx, this.imp, 4], [\"bcs\", this.bcs, this.rel, 2], [\"lda\", this.lda, this.izy, 5], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 5], [\"ldy\", this.ldy, this.zpx, 4], [\"lda\", this.lda, this.zpx, 4], [\"ldx\", this.ldx, this.zpy, 4], [\"???\", this.xxx, this.imp, 4], [\"clv\", this.clv, this.imp, 2], [\"lda\", this.lda, this.aby, 4], [\"tsx\", this.tsx, this.imp, 2], [\"???\", this.xxx, this.imp, 4], [\"ldy\", this.ldy, this.abx, 4], [\"lda\", this.lda, this.abx, 4], [\"ldx\", this.ldx, this.aby, 4], [\"???\", this.xxx, this.imp, 4], [\"cpy\", this.cpy, this.imm, 2], [\"cmp\", this.cmp, this.izx, 6], [\"???\", this.nop, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"cpy\", this.cpy, this.zp, 3], [\"cmp\", this.cmp, this.zp, 3], [\"dec\", this.dec, this.zp, 5], [\"???\", this.xxx, this.imp, 5], [\"iny\", this.iny, this.imp, 2], [\"cmp\", this.cmp, this.imm, 2], [\"dex\", this.dex, this.imp, 2], [\"???\", this.xxx, this.imp, 2], [\"cpy\", this.cpy, this.abs, 4], [\"cmp\", this.cmp, this.abs, 4], [\"dec\", this.dec, this.abs, 6], [\"???\", this.xxx, this.imp, 6], [\"bne\", this.bne, this.rel, 2], [\"cmp\", this.cmp, this.izy, 5], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"???\", this.nop, this.imp, 4], [\"cmp\", this.cmp, this.zpx, 4], [\"dec\", this.dec, this.zpx, 6], [\"???\", this.xxx, this.imp, 6], [\"cld\", this.cld, this.imp, 2], [\"cmp\", this.cmp, this.aby, 4], [\"nop\", this.nop, this.imp, 2], [\"???\", this.xxx, this.imp, 7], [\"???\", this.nop, this.imp, 4], [\"cmp\", this.cmp, this.abx, 4], [\"dec\", this.dec, this.abx, 7], [\"???\", this.xxx, this.imp, 7], [\"cpx\", this.cpx, this.imm, 2], [\"sbc\", this.sbc, this.izx, 6], [\"???\", this.nop, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"cpx\", this.cpx, this.zp, 3], [\"sbc\", this.sbc, this.zp, 3], [\"inc\", this.inc, this.zp, 5], [\"???\", this.xxx, this.imp, 5], [\"inx\", this.inx, this.imp, 2], [\"sbc\", this.sbc, this.imm, 2], [\"nop\", this.nop, this.imp, 2], [\"???\", this.sbc, this.imp, 2], [\"cpx\", this.cpx, this.abs, 4], [\"sbc\", this.sbc, this.abs, 4], [\"inc\", this.inc, this.abs, 6], [\"???\", this.xxx, this.imp, 6], [\"beq\", this.beq, this.rel, 2], [\"sbc\", this.sbc, this.izy, 5], [\"???\", this.xxx, this.imp, 2], [\"???\", this.xxx, this.imp, 8], [\"???\", this.nop, this.imp, 4], [\"sbc\", this.sbc, this.zpx, 4], [\"inc\", this.inc, this.zpx, 6], [\"???\", this.xxx, this.imp, 6], [\"sed\", this.sed, this.imp, 2], [\"sbc\", this.sbc, this.aby, 4], [\"nop\", this.nop, this.imp, 2], [\"???\", this.xxx, this.imp, 7], [\"???\", this.nop, this.imp, 4], [\"sbc\", this.sbc, this.abx, 4], [\"inc\", this.inc, this.abx, 7], [\"???\", this.xxx, this.imp, 7]];\n    this.ASMlookup = this.ASMlookup.map(function (item) {\n      return {\n        name: item[0],\n        operate: item[1],\n        addrmode: item[2],\n        cycles: item[3]\n      };\n    });\n  }\n\n  _createClass(Cpu6502, [{\n    key: \"GetFlag\",\n    value: function GetFlag(flag) {\n      if (flag === olc6502.FLAGS6502.U) {\n        return this.U;\n      }\n\n      if (flag === olc6502.FLAGS6502.B) {\n        return this.B;\n      }\n\n      if (flag === olc6502.FLAGS6502.C) {\n        return this.C;\n      }\n\n      if (flag === olc6502.FLAGS6502.D) {\n        return this.D;\n      }\n\n      if (flag === olc6502.FLAGS6502.I) {\n        return this.I;\n      }\n    }\n  }, {\n    key: \"ConnectBus\",\n    value: function ConnectBus(bus) {\n      this.bus = bus;\n      bus.cpu = this;\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      return this.cycles === 0;\n    }\n  }, {\n    key: \"irq\",\n    value: function irq() {\n      // If interrupts are allowed\n      if (this.I === 0) {\n        // Push the program counter to the stack. It's 16-bits dont\n        // forget so that takes two pushes\n        this.write(0x0100 + this.S, this.pc >> 8 & 0x00FF);\n        this.S--;\n        this.write(0x0100 + this.S, this.pc & 0x00FF);\n        this.S--; // Then Push the status register to the stack\n\n        this.B = 0;\n        this.U = 1;\n        this.I = 1;\n        var v = this.N << 7;\n        v |= this.V << 6;\n        v |= 3 << 4;\n        v |= this.D << 3;\n        v |= this.I << 2;\n        v |= this.Z << 1;\n        v |= this.C;\n        this.write(0x0100 + this.S, v);\n        this.S--; // Read new program counter location from fixed address\n\n        this.addr = 0xFFFE;\n        var lo = this.read(this.addr + 0);\n        var hi = this.read(this.addr + 1);\n        this.pc = hi << 8 | lo; // IRQs take time\n\n        this.cycles = 7;\n      }\n    } // A Non-Maskable Interrupt cannot be ignored. It behaves in exactly the\n    // same way as a regular IRQ, but reads the new program counter address\n    // form location 0xFFFA.\n\n  }, {\n    key: \"nmi\",\n    value: function nmi() {\n      this.write(0x0100 + this.S, this.pc >> 8 & 0x00FF);\n      this.S--;\n      this.write(0x0100 + this.S, this.pc & 0x00FF);\n      this.S--;\n      this.B = 0;\n      this.U = 1;\n      this.I = 1;\n      var v = this.N << 7;\n      v |= this.V << 6;\n      v |= 3 << 4;\n      v |= this.D << 3;\n      v |= this.I << 2;\n      v |= this.Z << 1;\n      v |= this.C;\n      this.write(0x0100 + this.S, v);\n      this.S--;\n      this.addr = 0xFFFA;\n      var lo = this.read(this.addr + 0);\n      var hi = this.read(this.addr + 1);\n      this.pc = hi << 8 | lo;\n      this.cycles = 8;\n    } // This is the disassembly function. Its workings are not required for emulation.\n    // It is merely a convenience function to turn the binary instruction code into\n    // human readable form. Its included as part of the emulator because it can take\n    // advantage of many of the CPUs internal operations to do this.\n\n  }, {\n    key: \"disassemble\",\n    value: function disassemble(nStart, nStop) {\n      var addr = nStart;\n      var value = 0x00,\n          lo = 0x00,\n          hi = 0x00;\n      var mapLines = [];\n      var line_addr = 0; // A convenient utility to convert variables into\n      // hex strings because \"modern C++\"'s method with\n      // streams is atrocious\n\n      var hex = function hex(n, d) {\n        var s = [];\n\n        for (var i = d - 1; i >= 0; i--, n >>= 4) {\n          s[i] = \"0123456789ABCDEF\"[n & 0xF];\n        }\n\n        return s.join('');\n      }; // Starting at the specified address we read an instruction\n      // byte, which in turn yields information from the lookup table\n      // as to how many additional bytes we need to read and what the\n      // addressing mode is. I need this info to assemble human readable\n      // syntax, which is different depending upon the addressing mode\n      // As the instruction is decoded, a std::string is assembled\n      // with the readable output\n\n\n      while (addr <= nStop) {\n        line_addr = addr; // Prefix line with instruction address\n\n        var sInst = \"$\" + hex(addr, 4) + \": \"; // Read instruction, and get its readable name\n\n        var pcode = this.bus.cpuRead(addr, true) || 0;\n        addr++;\n        sInst += this.ASMlookup[pcode].name + \" \"; // Get oprands from desired locations, and form the\n        // instruction based upon its addressing mode. These\n        // routines mimmick the actual fetch routine of the\n        // 6502 in order to get accurate data as part of the\n        // instruction\n\n        if (this.ASMlookup[pcode].addrmode === this.imp) {\n          sInst += \" {IMP}\";\n        } else if (this.ASMlookup[pcode].addrmode === this.imm) {\n          value = this.bus.cpuRead(addr, true);\n          addr++;\n          sInst += \"#$\" + hex(value, 2) + \" {IMM}\";\n        } else if (this.ASMlookup[pcode].addrmode === this.zp) {\n          lo = this.bus.cpuRead(addr, true);\n          addr++;\n          hi = 0x00;\n          sInst += \"$\" + hex(lo, 2) + \" {zp }\";\n        } else if (this.ASMlookup[pcode].addrmode === this.zpx) {\n          lo = this.bus.cpuRead(addr, true);\n          addr++;\n          hi = 0x00;\n          sInst += \"$\" + hex(lo, 2) + \", X {ZPX}\";\n        } else if (this.ASMlookup[pcode].addrmode === this.zpy) {\n          lo = this.bus.cpuRead(addr, true);\n          addr++;\n          hi = 0x00;\n          sInst += \"$\" + hex(lo, 2) + \", Y {ZPY}\";\n        } else if (this.ASMlookup[pcode].addrmode === this.izx) {\n          lo = this.bus.cpuRead(addr, true);\n          addr++;\n          hi = 0x00;\n          sInst += \"($\" + hex(lo, 2) + \", X) {IZX}\";\n        } else if (this.ASMlookup[pcode].addrmode === this.izy) {\n          lo = this.bus.cpuRead(addr, true);\n          addr++;\n          hi = 0x00;\n          sInst += \"($\" + hex(lo, 2) + \"), Y {IZY}\";\n        } else if (this.ASMlookup[pcode].addrmode === this.abs) {\n          lo = this.bus.cpuRead(addr, true);\n          addr++;\n          hi = this.bus.cpuRead(addr, true);\n          addr++;\n          sInst += \"$\" + hex(hi << 8 | lo, 4) + \" {ABS}\";\n        } else if (this.ASMlookup[pcode].addrmode === this.abx) {\n          lo = this.bus.cpuRead(addr, true);\n          addr++;\n          hi = this.bus.cpuRead(addr, true);\n          addr++;\n          sInst += \"$\" + hex(hi << 8 | lo, 4) + \", X {ABX}\";\n        } else if (this.ASMlookup[pcode].addrmode === this.aby) {\n          lo = this.bus.cpuRead(addr, true);\n          addr++;\n          hi = this.bus.cpuRead(addr, true);\n          addr++;\n          sInst += \"$\" + hex(hi << 8 | lo, 4) + \", Y {ABY}\";\n        } else if (this.ASMlookup[pcode].addrmode === this.ind) {\n          lo = this.bus.cpuRead(addr, true);\n          addr++;\n          hi = this.bus.cpuRead(addr, true);\n          addr++;\n          sInst += \"($\" + hex(hi << 8 | lo, 4) + \") {IND}\";\n        } else if (this.ASMlookup[pcode].addrmode === this.rel) {\n          value = this.bus.cpuRead(addr, true);\n          addr++;\n          sInst += \"$\" + hex(value, 2) + \" [$\" + hex(addr + value, 4) + \"] {REL}\";\n        } // Add the formed string to a std::map, using the instruction's\n        // address as the key. This makes it convenient to look for later\n        // as the instructions are variable in length, so a straight up\n        // incremental index is not sufficient.\n\n\n        mapLines[line_addr] = sInst;\n      }\n\n      return mapLines;\n    } ////////////////////////////////////////////////////////////////////////////////\n    // CPU control\n    ////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Reset the processor\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.A = 0;\n      this.X = 0;\n      this.Y = 0;\n      this.S = 0;\n      this.N = 0;\n      this.Z = 1;\n      this.C = 0;\n      this.V = 0;\n      this.I = 0;\n      this.D = 0;\n      this.pc = this.read(0xFFFD) << 8 | this.read(0xFFFC);\n    }\n    /**\n     * Execute a single opcode\n     */\n\n  }, {\n    key: \"step\",\n    value: function step() {\n      this.opcode = this.read(this.pc++);\n      this.lookup[this.opcode].operate.bind(this);\n      this.lookup[this.opcode].addrmode.bind(this);\n    }\n  }, {\n    key: \"clock\",\n    value: function clock() {\n      // Each instruction requires a variable number of clock cycles to execute.\n      // In my emulation, I only care about the final result and so I perform\n      // the entire computation in one hit. In hardware, each clock cycle would\n      // perform \"microcode\" style transformations of the CPUs state.\n      //\n      // To remain compliant with connected devices, it's important that the\n      // emulation also takes \"time\" in order to execute instructions, so I\n      // implement that delay by simply counting down the cycles required by\n      // the instruction. When it reaches 0, the instruction is complete, and\n      // the next one is ready to be executed.\n      if (this.cycles === 0) {\n        // Read next instruction byte. This 8-bit value is used to index\n        // the translation table to get the relevant information about\n        // how to implement the instruction\n        this.opcode = this.read(this.pc++) || 0; // Always set the unused status flag bit to 1\n\n        this.U = 1; // Increment program counter, we read the opcode byte\n        //this.pc++;\n        // Get Starting number of cycles\n        //this.cycles = this.lookup[this.opcode].cycles;\n        // Perform fetch of intermmediate data using the\n        // required addressing mode\n\n        for (var i in this.lookup[this.opcode]) {\n          try {\n            this.lookup[this.opcode][i].bind(this)();\n          } catch (e) {//debugger;\n          }\n        } //let additional_cycle1 = (;\n        // Perform operation\n        //let additional_cycle2 = (this.lookup[this.opcode].operate).bind(this)();\n        // The addressmode and opcode may have altered the number\n        // of cycles this instruction requires before its completed\n        //this.cycles += (additional_cycle1 & additional_cycle2);\n        // Always set the unused status flag bit to 1\n\n\n        this.U = 1;\n        /*#ifdef LOGMODE\n        // This logger dumps every cycle the entire processor state for analysis.\n        // This can be used for debugging the emulation, but has little utility\n        // during emulation. Its also very slow, so only use if you have to.\n        if (logfile == nullptr)\tlogfile = fopen(\"olc6502.txt\", \"wt\");\n        if (logfile != nullptr)\n        {\n        \tfprintf(logfile, \"%10d:%02d PC:%04X %s A:%02X X:%02X Y:%02X %s%s%s%s%s%s%s%s STKP:%02X\\n\",\n        \t\tclock_count, 0, log_pc, \"XXX\", a, x, y,\n        \t\tGetFlag(N) ? \"N\" : \".\",\tGetFlag(V) ? \"V\" : \".\",\tGetFlag(U) ? \"U\" : \".\",\n        \t\tGetFlag(B) ? \"B\" : \".\",\tGetFlag(D) ? \"D\" : \".\",\tGetFlag(I) ? \"I\" : \".\",\n        \t\tGetFlag(Z) ? \"Z\" : \".\",\tGetFlag(C) ? \"C\" : \".\",\tstkp);\n        }\n        #endif*/\n      } // Increment global clock count - This is actually unused unless logging is enabled\n      // but I've kept it in because its a handy watch variable for debugging\n\n\n      this.clock_count++; // Decrement the number of cycles remaining for this instruction\n\n      this.cycles--;\n    }\n    /**\n     * Log the current cycle count and all registers to console.log\n     */\n\n  }, {\n    key: \"log\",\n    value: function log() {\n      var msg = \"nPC=\" + this.pc.toString(16);\n      msg += \" cyc=\" + this.cycles;\n      msg += \" [\" + this.opcode.toString(16) + \"] \";\n      msg += this.C ? \"C\" : \"-\";\n      msg += this.N ? \"N\" : \"-\";\n      msg += this.Z ? \"Z\" : \"-\";\n      msg += this.V ? \"V\" : \"-\";\n      msg += this.D ? \"D\" : \"-\";\n      msg += this.I ? \"I\" : \"-\";\n      msg += \" A=\" + this.A.toString(16);\n      msg += \" X=\" + this.X.toString(16);\n      msg += \" Y=\" + this.Y.toString(16);\n      msg += \" S=\" + this.S.toString(16);\n    }\n    /**\n     * Read a memory location. This function must be overridden with a custom implementation.\n     * @param {number} addr - The address to read from.\n     */\n\n  }, {\n    key: \"read\",\n    value: function read(addr) {\n      return this.bus.cpuRead(addr, false);\n    }\n    /**\n     * Writa a value to a memory location. This function must be overridden with a custom implementation.\n     * @param {number} addr - The address to write to.\n     * @param {number} value - The value to write.\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(addr, value) {\n      this.bus.cpuWrite(addr, value);\n    } ////////////////////////////////////////////////////////////////////////////////\n    // Subroutines - addressing modes & flags\n    ////////////////////////////////////////////////////////////////////////////////\n\n  }, {\n    key: \"kil\",\n    value: function kil() {\n      return 0;\n    }\n  }, {\n    key: \"izx\",\n    value: function izx() {\n      var a = this.read(this.pc++) + this.X & 0xFF;\n      this.addr = this.read(a + 1 & 0xFF) << 8 | this.read(a);\n      this.cycles += 6;\n    }\n  }, {\n    key: \"izy\",\n    value: function izy() {\n      var t = this.read(this.pc++);\n      var lo = this.read(t & 0x00FF);\n      var hi = this.read(t + 1 & 0x00FF);\n      this.addr = hi << 8 | lo;\n      this.addr = this.addr + this.Y & 0xFFFF;\n      if ((this.addr & 0xFF00) !== hi << 8) this.cycles += 6;else this.cycles += 5;\n      /*\n      var a = this.read(this.pc++);\n      var paddr = (this.read((a + 1) & 0xFF) << 8) | this.read(a);\n      this.addr = (paddr + this.Y) & 0xFF;\n      if ( (paddr & 0x100) !== (this.addr & 0x100) ) {\n      \tthis.cycles += 6;\n      } else {\n      \tthis.cycles += 5;\n      }*/\n    }\n  }, {\n    key: \"izyp\",\n    value: function izyp() {\n      var a = this.read(this.pc++);\n      var paddr = this.read(a + 1 & 0xFF) << 8 | this.read(a);\n      this.addr = paddr + this.Y;\n      this.cycles += 6;\n    }\n  }, {\n    key: \"ind\",\n    value: function ind() {\n      var a = this.read(this.pc++);\n      a |= this.read(this.pc++) << 8;\n      this.addr = this.read(a);\n      this.addr |= this.read(a & 0xFF00 | a + 1 & 0xFF) << 8;\n      this.cycles += 6;\n    }\n  }, {\n    key: \"zp\",\n    value: function zp() {\n      this.addr = this.read(this.pc++);\n      this.cycles += 3;\n    }\n  }, {\n    key: \"zpx\",\n    value: function zpx() {\n      this.addr = this.read(this.pc++) + this.X & 0xFF;\n      this.cycles += 4;\n    }\n  }, {\n    key: \"zpy\",\n    value: function zpy() {\n      this.addr = this.read(this.pc++) + this.Y & 0xFF;\n      this.cycles += 4;\n    }\n  }, {\n    key: \"imp\",\n    value: function imp() {\n      this.cycles += 2;\n    }\n  }, {\n    key: \"imm\",\n    value: function imm() {\n      this.addr = this.pc++;\n      this.cycles += 2;\n    }\n  }, {\n    key: \"abs\",\n    value: function abs() {\n      this.addr = this.read(this.pc++);\n      this.addr |= this.read(this.pc++) << 8;\n      this.cycles += 4;\n    }\n  }, {\n    key: \"abx\",\n    value: function abx() {\n      var paddr = this.read(this.pc++);\n      paddr |= this.read(this.pc++) << 8;\n      this.addr = paddr + this.X;\n\n      if ((paddr & 0x100) != (this.addr & 0x100)) {\n        this.cycles += 5;\n      } else {\n        this.cycles += 4;\n      }\n    }\n  }, {\n    key: \"abxp\",\n    value: function abxp() {\n      var paddr = this.read(this.pc++);\n      paddr |= this.read(this.pc++) << 8;\n      this.addr = paddr + this.X;\n      this.cycles += 5;\n    }\n  }, {\n    key: \"aby\",\n    value: function aby() {\n      var paddr = this.read(this.pc++);\n      paddr |= this.read(this.pc++) << 8;\n      this.addr = paddr + this.Y & 0xFFFF;\n\n      if ((paddr & 0x100) != (this.addr & 0x100)) {\n        this.cycles += 5;\n      } else {\n        this.cycles += 4;\n      }\n    }\n  }, {\n    key: \"abyp\",\n    value: function abyp() {\n      var paddr = this.read(this.pc++);\n      paddr |= this.read(this.pc++) << 8;\n      this.addr = paddr + this.Y & 0xFFFF;\n      this.cycles += 5;\n    }\n  }, {\n    key: \"rel\",\n    value: function rel() {\n      this.addr = this.read(this.pc++);\n\n      if (this.addr & 0x80) {\n        this.addr -= 0x100;\n      }\n\n      this.addr += this.pc;\n      this.cycles += 2;\n    }\n  }, {\n    key: \"rmw\",\n    value: function rmw() {\n      this.write(this.addr, this.tmp & 0xFF);\n      this.cycles += 2;\n    }\n  }, {\n    key: \"fnz\",\n    value: function fnz(v) {\n      this.Z = (v & 0xFF) == 0 ? 1 : 0;\n      this.N = (v & 0x80) != 0 ? 1 : 0;\n    } // Borrow\n\n  }, {\n    key: \"fnzb\",\n    value: function fnzb(v) {\n      this.Z = (v & 0xFF) == 0 ? 1 : 0;\n      this.N = (v & 0x80) != 0 ? 1 : 0;\n      this.C = (v & 0x100) != 0 ? 0 : 1;\n    } // Carry\n\n  }, {\n    key: \"fnzc\",\n    value: function fnzc(v) {\n      this.Z = (v & 0xFF) == 0 ? 1 : 0;\n      this.N = (v & 0x80) != 0 ? 1 : 0;\n      this.C = (v & 0x100) != 0 ? 1 : 0;\n    }\n  }, {\n    key: \"branch\",\n    value: function branch(v) {\n      if (v) {\n        if ((this.addr & 0x100) != (this.pc & 0x100)) {\n          this.cycles += 2;\n        } else {\n          this.cycles += 1;\n        }\n\n        this.pc = this.addr;\n      }\n    } ////////////////////////////////////////////////////////////////////////////////\n    // Subroutines - instructions\n    ////////////////////////////////////////////////////////////////////////////////\n\n  }, {\n    key: \"adc\",\n    value: function adc() {\n      var v = this.read(this.addr);\n      var c = this.C;\n      var r = this.A + v + c;\n      this.Z = (r & 0xFF) == 0 ? 1 : 0;\n      this.N = (r & 0x80) != 0 ? 1 : 0;\n      this.V = (~(this.A ^ v) & (this.A ^ r) & 0x80) != 0 ? 1 : 0;\n      this.C = (r & 0x100) != 0 ? 1 : 0;\n      this.A = r & 0xFF;\n      /*\n      if (this.D) {\n      \tvar al = (this.A & 0x0F) + (v & 0x0F) + c;\n      \tif (al > 9) al += 6;\n      \tvar ah = (this.A >> 4) + (v >> 4) + ((al > 15) ? 1 : 0);\n      \tthis.Z = ((r & 0xFF) == 0) ? 1 : 0;\n      \tthis.N = ((ah & 8) != 0) ? 1 : 0;\n      \tthis.V = ((~(this.A ^ v) & (this.A ^ (ah << 4)) & 0x80) != 0) ? 1 : 0;\n      \tif (ah > 9) ah += 6;\n      \tthis.C = (ah > 15) ? 1 : 0;\n      \tthis.A = ((ah << 4) | (al & 15)) & 0xFF;\n      } else {\n      \t}*/\n    }\n  }, {\n    key: \"ahx\",\n    value: function ahx() {\n      this.tmp = (this.addr >> 8) + 1 & this.A & this.X;\n      this.write(this.addr, this.tmp & 0xFF);\n    }\n  }, {\n    key: \"alr\",\n    value: function alr() {\n      this.tmp = this.read(this.addr) & this.A;\n      this.tmp = (this.tmp & 1) << 8 | this.tmp >> 1;\n      this.fnzc(this.tmp);\n      this.A = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"anc\",\n    value: function anc() {\n      this.tmp = this.read(this.addr);\n      this.tmp |= (this.tmp & 0x80 & (this.A & 0x80)) << 1;\n      this.fnzc(this.tmp);\n      this.A = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"and\",\n    value: function and() {\n      this.A &= this.read(this.addr);\n      this.fnz(this.A);\n    }\n  }, {\n    key: \"ane\",\n    value: function ane() {\n      this.tmp = this.read(this.addr) & this.A & (this.A | 0xEE);\n      this.fnz(this.tmp);\n      this.A = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"arr\",\n    value: function arr() {\n      this.tmp = this.read(this.adfdr) & this.A;\n      this.C = (this.tmp & 0x80) != 0;\n      this.V = (this.tmp >> 7 & 1 ^ this.tmp >> 6 & 1) != 0;\n\n      if (this.D) {\n        var al = (this.tmp & 0x0F) + (this.tmp & 1);\n        if (al > 5) al += 6;\n        var ah = (this.tmp >> 4 & 0x0F) + (this.tmp >> 4 & 1);\n\n        if (ah > 5) {\n          al += 6;\n          this.C = true;\n        } else {\n          this.C = false;\n        }\n\n        this.tmp = ah << 4 | al;\n      }\n\n      this.fnz(this.tmp);\n      this.A = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"asl\",\n    value: function asl() {\n      this.tmp = this.read(this.addr) << 1;\n      this.fnzc(this.tmp);\n      this.tmp &= 0xFF;\n    }\n  }, {\n    key: \"asla\",\n    value: function asla() {\n      this.tmp = this.A << 1;\n      this.fnzc(this.tmp);\n      this.A = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"bit\",\n    value: function bit() {\n      this.tmp = this.read(this.addr);\n      this.N = (this.tmp & 0x80) != 0 ? 1 : 0;\n      this.V = (this.tmp & 0x40) != 0 ? 1 : 0;\n      this.Z = (this.tmp & this.A) == 0 ? 1 : 0;\n    }\n  }, {\n    key: \"brk\",\n    value: function brk() {\n      this.pc++;\n      this.write(this.S + 0x100, this.pc >> 8);\n      this.S = this.S - 1 & 0xFF;\n      this.write(this.S + 0x100, this.pc & 0xFF);\n      this.S = this.S - 1 & 0xFF;\n      var v = this.N << 7;\n      v |= this.V << 6;\n      v |= 3 << 4;\n      v |= this.D << 3;\n      v |= this.I << 2;\n      v |= this.Z << 1;\n      v |= this.C;\n      this.write(this.S + 0x100, v);\n      this.S = this.S - 1 & 0xFF;\n      this.I = 1;\n      this.D = 0;\n      this.pc = this.read(0xFFFF) << 8 | this.read(0xFFFE);\n      this.cycles += 5;\n    }\n  }, {\n    key: \"bcc\",\n    value: function bcc() {\n      this.branch(this.C == 0);\n    }\n  }, {\n    key: \"bcs\",\n    value: function bcs() {\n      this.branch(this.C == 1);\n    }\n  }, {\n    key: \"beq\",\n    value: function beq() {\n      this.branch(this.Z == 1);\n    }\n  }, {\n    key: \"bne\",\n    value: function bne() {\n      this.branch(this.Z == 0);\n    }\n  }, {\n    key: \"bmi\",\n    value: function bmi() {\n      this.branch(this.N == 1);\n    }\n  }, {\n    key: \"bpl\",\n    value: function bpl() {\n      this.branch(this.N == 0);\n    }\n  }, {\n    key: \"bvc\",\n    value: function bvc() {\n      this.branch(this.V == 0);\n    }\n  }, {\n    key: \"bvs\",\n    value: function bvs() {\n      this.branch(this.V == 1);\n    }\n  }, {\n    key: \"clc\",\n    value: function clc() {\n      this.C = 0;\n    }\n  }, {\n    key: \"cld\",\n    value: function cld() {\n      this.D = 0;\n    }\n  }, {\n    key: \"cli\",\n    value: function cli() {\n      this.I = 0;\n    }\n  }, {\n    key: \"clv\",\n    value: function clv() {\n      this.V = 0;\n    }\n  }, {\n    key: \"cmp\",\n    value: function cmp() {\n      this.fnzb(this.A - this.read(this.addr));\n    }\n  }, {\n    key: \"cpx\",\n    value: function cpx() {\n      this.fnzb(this.X - this.read(this.addr));\n    }\n  }, {\n    key: \"cpy\",\n    value: function cpy() {\n      this.fnzb(this.Y - this.read(this.addr));\n    }\n  }, {\n    key: \"dcp\",\n    value: function dcp() {\n      this.tmp = this.read(this.addr) - 1 & 0xFF;\n      this.tmp = this.A - this.tmp;\n      this.fnz(this.tmp);\n    }\n  }, {\n    key: \"dec\",\n    value: function dec() {\n      this.tmp = this.read(this.addr) - 1 & 0xFF;\n      this.fnz(this.tmp);\n    }\n  }, {\n    key: \"dex\",\n    value: function dex() {\n      this.X = this.X - 1 & 0xFF;\n      this.fnz(this.X);\n    }\n  }, {\n    key: \"dey\",\n    value: function dey() {\n      this.Y = this.Y - 1 & 0xFF;\n      this.fnz(this.Y);\n    }\n  }, {\n    key: \"eor\",\n    value: function eor() {\n      this.A ^= this.read(this.addr);\n      this.fnz(this.A);\n    }\n  }, {\n    key: \"inc\",\n    value: function inc() {\n      this.tmp = this.read(this.addr) + 1 & 0xFF;\n      this.fnz(this.tmp);\n    }\n  }, {\n    key: \"inx\",\n    value: function inx() {\n      this.X = this.X + 1 & 0xFF;\n      this.fnz(this.X);\n    }\n  }, {\n    key: \"iny\",\n    value: function iny() {\n      this.Y = this.Y + 1 & 0xFF;\n      this.fnz(this.Y);\n    }\n  }, {\n    key: \"isc\",\n    value: function isc() {\n      var v = this.read(this.addr) + 1 & 0xFF;\n      var c = 1 - (this.C ? 1 : 0);\n      var r = this.A - v - c;\n\n      if (this.D) {\n        var al = (this.A & 0x0F) - (v & 0x0F) - c;\n        if (al > 0x80) al -= 6;\n        var ah = (this.A >> 4) - (v >> 4) - (al > 0x80 ? 1 : 0);\n        this.Z = (r & 0xFF) == 0;\n        this.N = (r & 0x80) != 0;\n        this.V = ((this.A ^ v) & (this.A ^ r) & 0x80) != 0;\n        this.C = (this.r & 0x100) != 0 ? 0 : 1;\n        if (ah > 0x80) ah -= 6;\n        this.A = (ah << 4 | al & 15) & 0xFF;\n      } else {\n        this.Z = (r & 0xFF) == 0;\n        this.N = (r & 0x80) != 0;\n        this.V = ((this.A ^ v) & (this.A ^ r) & 0x80) != 0;\n        this.C = (r & 0x100) != 0 ? 0 : 1;\n        this.A = r & 0xFF;\n      }\n    }\n  }, {\n    key: \"jmp\",\n    value: function jmp() {\n      this.pc = this.addr;\n      this.cycles--;\n    }\n  }, {\n    key: \"jsr\",\n    value: function jsr() {\n      this.write(this.S + 0x100, this.pc - 1 >> 8);\n      this.S = this.S - 1 & 0xFF;\n      this.write(this.S + 0x100, this.pc - 1 & 0xFF);\n      this.S = this.S - 1 & 0xFF;\n      this.pc = this.addr;\n      this.cycles += 2;\n    }\n  }, {\n    key: \"las\",\n    value: function las() {\n      this.S = this.X = this.A = this.read(this.addr) & this.S;\n      this.fnz(this.A);\n    }\n  }, {\n    key: \"lax\",\n    value: function lax() {\n      this.X = this.A = this.read(this.addr);\n      this.fnz(this.A);\n    }\n  }, {\n    key: \"lda\",\n    value: function lda() {\n      this.A = this.read(this.addr);\n      this.fnz(this.A);\n    }\n  }, {\n    key: \"ldx\",\n    value: function ldx() {\n      this.X = this.read(this.addr);\n      this.fnz(this.X);\n    }\n  }, {\n    key: \"ldy\",\n    value: function ldy() {\n      this.Y = this.read(this.addr);\n      this.fnz(this.Y);\n    }\n  }, {\n    key: \"ora\",\n    value: function ora() {\n      this.A |= this.read(this.addr);\n      this.fnz(this.A);\n    }\n  }, {\n    key: \"rol\",\n    value: function rol() {\n      this.tmp = this.read(this.addr) << 1 | this.C;\n      this.fnzc(this.tmp);\n      this.tmp &= 0xFF;\n    }\n  }, {\n    key: \"rla\",\n    value: function rla() {\n      this.tmp = this.A << 1 | this.C;\n      this.fnzc(this.tmp);\n      this.A = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"ror\",\n    value: function ror() {\n      this.tmp = this.read(this.addr);\n      this.tmp = (this.tmp & 1) << 8 | this.C << 7 | this.tmp >> 1;\n      this.fnzc(this.tmp);\n      this.tmp &= 0xFF;\n    }\n  }, {\n    key: \"rra\",\n    value: function rra() {\n      this.tmp = (this.A & 1) << 8 | this.C << 7 | this.A >> 1;\n      this.fnzc(this.tmp);\n      this.A = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"lsr\",\n    value: function lsr() {\n      this.tmp = this.read(this.addr);\n      this.tmp = (this.tmp & 1) << 8 | this.tmp >> 1;\n      this.fnzc(this.tmp);\n      this.tmp &= 0xFF;\n    }\n  }, {\n    key: \"lsra\",\n    value: function lsra() {\n      this.tmp = (this.A & 1) << 8 | this.A >> 1;\n      this.fnzc(this.tmp);\n      this.A = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"nop\",\n    value: function nop() {}\n  }, {\n    key: \"pha\",\n    value: function pha() {\n      this.write(this.S + 0x100, this.A);\n      this.S = this.S - 1 & 0xFF;\n      this.cycles++;\n    }\n  }, {\n    key: \"php\",\n    value: function php() {\n      var v = this.N << 7;\n      v |= this.V << 6;\n      v |= 3 << 4;\n      v |= this.D << 3;\n      v |= this.I << 2;\n      v |= this.Z << 1;\n      v |= this.C;\n      this.write(this.S + 0x100, v);\n      this.S = this.S - 1 & 0xFF;\n      this.cycles++;\n    }\n  }, {\n    key: \"pla\",\n    value: function pla() {\n      this.S = this.S + 1 & 0xFF;\n      this.A = this.read(this.S + 0x100);\n      this.fnz(this.A);\n      this.cycles += 2;\n    }\n  }, {\n    key: \"plp\",\n    value: function plp() {\n      this.S = this.S + 1 & 0xFF;\n      this.tmp = this.read(this.S + 0x100);\n      this.N = (this.tmp & 0x80) != 0 ? 1 : 0;\n      this.V = (this.tmp & 0x40) != 0 ? 1 : 0;\n      this.D = (this.tmp & 0x08) != 0 ? 1 : 0;\n      this.I = (this.tmp & 0x04) != 0 ? 1 : 0;\n      this.Z = (this.tmp & 0x02) != 0 ? 1 : 0;\n      this.C = (this.tmp & 0x01) != 0 ? 1 : 0;\n      this.cycles += 2;\n    }\n  }, {\n    key: \"rti\",\n    value: function rti() {\n      this.S = this.S + 1 & 0xFF;\n      this.tmp = this.read(this.S + 0x100);\n      this.N = (this.tmp & 0x80) != 0 ? 1 : 0;\n      this.V = (this.tmp & 0x40) != 0 ? 1 : 0;\n      this.D = (this.tmp & 0x08) != 0 ? 1 : 0;\n      this.I = (this.tmp & 0x04) != 0 ? 1 : 0;\n      this.Z = (this.tmp & 0x02) != 0 ? 1 : 0;\n      this.C = (this.tmp & 0x01) != 0 ? 1 : 0;\n      this.S = this.S + 1 & 0xFF;\n      this.pc = this.read(this.S + 0x100);\n      this.S = this.S + 1 & 0xFF;\n      this.pc |= this.read(this.S + 0x100) << 8;\n      this.cycles += 4;\n    }\n  }, {\n    key: \"rts\",\n    value: function rts() {\n      this.S = this.S + 1 & 0xFF;\n      this.pc = this.read(this.S + 0x100);\n      this.S = this.S + 1 & 0xFF;\n      this.pc |= this.read(this.S + 0x100) << 8;\n      this.pc++;\n      this.cycles += 4;\n    }\n  }, {\n    key: \"sbc\",\n    value: function sbc() {\n      var v = this.read(this.addr);\n      var c = 1 - this.C;\n      var r = this.A - v - c;\n\n      if (this.D) {\n        var al = (this.A & 0x0F) - (v & 0x0F) - c;\n        if (al < 0) al -= 6;\n        var ah = (this.A >> 4) - (v >> 4) - (al < 0 ? 1 : 0);\n        this.Z = (r & 0xFF) == 0 ? 1 : 0;\n        this.N = (r & 0x80) != 0 ? 1 : 0;\n        this.V = ((this.A ^ v) & (this.A ^ r) & 0x80) != 0 ? 1 : 0;\n        this.C = (r & 0x100) != 0 ? 0 : 1;\n        if (ah < 0) ah -= 6;\n        this.A = (ah << 4 | al & 15) & 0xFF;\n      } else {\n        this.Z = (r & 0xFF) == 0 ? 1 : 0;\n        this.N = (r & 0x80) != 0 ? 1 : 0;\n        this.V = ((this.A ^ v) & (this.A ^ r) & 0x80) != 0 ? 1 : 0;\n        this.C = (r & 0x100) != 0 ? 0 : 1;\n        this.A = r & 0xFF;\n      }\n    }\n  }, {\n    key: \"sbx\",\n    value: function sbx() {\n      this.tmp = this.read(this.addr) - (this.A & this.X);\n      this.fnzb(this.tmp);\n      this.X = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"sec\",\n    value: function sec() {\n      this.C = 1;\n    }\n  }, {\n    key: \"sed\",\n    value: function sed() {\n      this.D = 1;\n    }\n  }, {\n    key: \"sei\",\n    value: function sei() {\n      this.I = 1;\n    }\n  }, {\n    key: \"shs\",\n    value: function shs() {\n      this.tmp = (this.addr >> 8) + 1 & this.A & this.X;\n      this.write(this.addr, this.tmp & 0xFF);\n      this.S = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"shx\",\n    value: function shx() {\n      this.tmp = (this.addr >> 8) + 1 & this.X;\n      this.write(this.addr, this.tmp & 0xFF);\n    }\n  }, {\n    key: \"shy\",\n    value: function shy() {\n      this.tmp = (this.addr >> 8) + 1 & this.Y;\n      this.write(this.addr, this.tmp & 0xFF);\n    }\n  }, {\n    key: \"slo\",\n    value: function slo() {\n      this.tmp = this.read(this.addr) << 1;\n      this.tmp |= this.A;\n      this.fnzc(this.tmp);\n      this.A = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"sre\",\n    value: function sre() {\n      var v = this.read(this.addr);\n      this.tmp = (v & 1) << 8 | v >> 1;\n      this.tmp ^= this.A;\n      this.fnzc(this.tmp);\n      this.A = this.tmp & 0xFF;\n    }\n  }, {\n    key: \"sta\",\n    value: function sta() {\n      this.write(this.addr, this.A);\n    }\n  }, {\n    key: \"stx\",\n    value: function stx() {\n      this.write(this.addr, this.X);\n    }\n  }, {\n    key: \"sty\",\n    value: function sty() {\n      this.write(this.addr, this.Y);\n    }\n  }, {\n    key: \"tax\",\n    value: function tax() {\n      this.X = this.A;\n      this.fnz(this.X);\n    }\n  }, {\n    key: \"tay\",\n    value: function tay() {\n      this.Y = this.A;\n      this.fnz(this.Y);\n    }\n  }, {\n    key: \"tsx\",\n    value: function tsx() {\n      this.X = this.S;\n      this.fnz(this.X);\n    }\n  }, {\n    key: \"txa\",\n    value: function txa() {\n      this.A = this.X;\n      this.fnz(this.A);\n    }\n  }, {\n    key: \"txs\",\n    value: function txs() {\n      this.S = this.X;\n    }\n  }, {\n    key: \"tya\",\n    value: function tya() {\n      this.A = this.Y;\n      this.fnz(this.A);\n    }\n  }, {\n    key: \"xxx\",\n    value: function xxx() {\n      return 0;\n    }\n  }]);\n\n  return Cpu6502;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Cpu6502);\n\n//# sourceURL=webpack:///./src/Cpu6502.js?");

/***/ }),

/***/ "./src/lib/PIxel.js":
/*!**************************!*\
  !*** ./src/lib/PIxel.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Pixel = /*#__PURE__*/function () {\n  function Pixel(r, g, b) {\n    _classCallCheck(this, Pixel);\n\n    this.red = r;\n    this.green = g;\n    this.blue = b;\n  }\n\n  _createClass(Pixel, [{\n    key: \"hex\",\n    value: function hex(n, d) {\n      var s = [];\n\n      for (var i = d - 1; i >= 0; i--, n >>= 4) {\n        s[i] = \"0123456789ABCDEF\"[n & 0xF];\n      }\n\n      return s.join('');\n    }\n  }, {\n    key: \"getCode\",\n    value: function getCode() {\n      return '#' + this.hex(this.red, 2) + this.hex(this.green, 2) + this.hex(this.blue, 2);\n    }\n  }]);\n\n  return Pixel;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Pixel);\n\n//# sourceURL=webpack:///./src/lib/PIxel.js?");

/***/ }),

/***/ "./src/lib/Sprite.js":
/*!***************************!*\
  !*** ./src/lib/Sprite.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Sprite = /*#__PURE__*/function () {\n  function Sprite(canvas, width, height) {\n    _classCallCheck(this, Sprite);\n\n    this.width = width;\n    this.height = height;\n\n    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n      postMessage({\n        op: 'ctxInit',\n        width: this.width,\n        height: this.height\n      });\n    } else {\n      this.ctx = canvas.createImageData(this.width, this.height);\n    }\n  }\n\n  _createClass(Sprite, [{\n    key: \"FillPixel\",\n    value: function FillPixel(x, y, color) {\n      var cord = (y * this.width + x) * 4; //this.ctx.fillStyle = \"rgba(\"+color.r+\",\"+color.g+\",\"+color.b+\",255)\";\n\n      this.ctx.data[cord] = color.red; // R value\n\n      this.ctx.data[cord + 1] = color.green; // R value\n\n      this.ctx.data[cord + 2] = color.blue; // R value\n\n      this.ctx.data[cord + 3] = 255; // R value\n      //this.ctx.fillRect( x, y, 1, 1 );\n    }\n  }, {\n    key: \"SetPixel\",\n    value: function SetPixel(x, y, color) {\n      if (x > this.width || y > this.height || y < 0) {\n        return;\n      }\n\n      this.FillPixel(x, y, color);\n    }\n  }]);\n\n  return Sprite;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Sprite);\n\n//# sourceURL=webpack:///./src/lib/Sprite.js?");

/***/ }),

/***/ "./src/lib/Struct.js":
/*!***************************!*\
  !*** ./src/lib/Struct.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Struct = /*#__PURE__*/function () {\n  function Struct(struct) {\n    var _this = this;\n\n    _classCallCheck(this, Struct);\n\n    this.struct = [];\n    this.totalLength = 0;\n    this.bytes = 0;\n    Object.keys(struct).forEach(function (key) {\n      _this.totalLength++;\n      _this[key] = 0;\n      _this.bytes += struct[key];\n\n      _this.struct.push({\n        key: key,\n        bytes: struct[key]\n      });\n    });\n  }\n\n  _createClass(Struct, [{\n    key: \"setReg\",\n    value: function setReg(value) {\n      value = value.toString(2);\n\n      for (var i = 0; i < this.totalLength; i++) {\n        var val = value.substring(value.length - this.struct[i].bytes);\n        value = value.substring(0, value.length - this.struct[i].bytes);\n        this[this.struct[i].key] = parseInt(val || 0, 2);\n      }\n    }\n  }, {\n    key: \"reg\",\n    get: function get() {\n      var reg = 0;\n      var shift = 0;\n\n      for (var i = 0; i < this.totalLength; i++) {\n        reg |= this[this.struct[i].key] << shift;\n        shift += this.struct[i].bytes;\n      }\n\n      return reg;\n    },\n    set: function set(value) {\n      var shift = this.bytes;\n\n      for (var i = this.totalLength - 1; i >= 0; i--) {\n        shift -= this.struct[i].bytes;\n        var val = value >> shift;\n        value &= ~(1 << shift);\n        this[this.struct[i].key] = val;\n      }\n    }\n  }]);\n\n  return Struct;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Struct);\n\n//# sourceURL=webpack:///./src/lib/Struct.js?");

/***/ }),

/***/ "./src/lib/parseNes.js":
/*!*****************************!*\
  !*** ./src/lib/parseNes.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction parseNES(buf) {\n  var magic = buf.readUInt32BE(0);\n\n  switch (magic) {\n    case 0x554e4946:\n      // UNIF\n      return {\n        is_unif: true\n      };\n    // TODO: could parse this, but format is deprecated:\n    // https://wiki.nesdev.com/w/index.php/UNIF\n\n    case 0x4e45531a:\n      // NES^Z\n      break;\n\n    default:\n      throw new Error('Not a .nes file (bad magic)');\n  }\n\n  var info = {};\n  var prg_rom_16k = buf.readUInt8(4);\n  info.prg_rom_size = prg_rom_16k * 16384;\n  var chr_rom_8k = buf.readUInt8(5);\n  info.chr_rom_size = chr_rom_8k * 8192;\n  info.has_chr_ram = chr_rom_8k === 0; // \"(0 indicates CHR RAM)\"\n\n  var flags6 = buf.readUInt8(6);\n  info.mirroring = !!(flags6 & 1) ? 'vertical' : 'horizontal';\n  info.has_battery_backed_sram = !!(flags6 & 2);\n  info.has_trainer = !!(flags6 & 4);\n  info.four_screen_mode = !!(flags6 & 8);\n  info.mapper = flags6 >> 4;\n  var flags7 = buf.readUInt8(7);\n  info.is_vs_unisystem = !!(flags7 & 1);\n  info.is_playchoice10 = !!(flags7 & 2);\n  info.is_nes2_0 = (flags7 & 4) >> 2 === 2;\n  info.mapper |= flags7 & 0xf0; // https://wiki.nesdev.com/w/index.php/INES#Variant_comparison\n  // Recommended detection procedure:\n  // If byte 7 AND $0C = $08, and the size taking into account byte 9 does not exceed the actual size of the ROM image, then NES 2.0.\n  // If byte 7 AND $0C = $00, and bytes 12-15 are all 0, then iNES.\n  // Otherwise, archaic iNES.\n\n  info.is_nes2_0 = (flags7 & 0x0c) === 0x08; // TODO: also check \"the size taking into account byte 9 does not exceed the actual size of the ROM image\"\n\n  info.is_ines = (flags7 & 0x0c) === 0; // TODO: also check \"bytes 12-15 are all 0\"\n\n  if (!info.is_nes2_0 && !info.is_ines) {\n    info.is_archaic = true;\n  } // https://wiki.nesdev.com/w/index.php/INES#iNES_file_format says this was PRG RAM size\n  // but https://wiki.nesdev.com/w/index.php/NES_2.0#Byte_8_.28Mapper_variant.29 says mapper variant\n\n\n  if (!info.is_nes2_0) {\n    var prg_ram_8k = buf.readUInt8(8);\n    info.prg_ram_size = prg_ram_8k * 8192;\n    var flags9 = buf.readUInt8(9);\n    info.tv_system9_pal = !!(flags9 & 1) ? 'PAL' : 'NTSC';\n    info.reserved9 = flags9 >> 1;\n    var flags10 = buf.readUInt8(10);\n    info.tv_system10 = flags10 & 3;\n    info.has_prg_ram = !!(flags10 & 16);\n    info.has_bus_conflicts = !!(flags10 & 32);\n  } // NES 2.0\n\n\n  if (info.is_nes2_0) {\n    // \"Bytes 10 and 11 of the header define the size of the RAM segments exponentially using 4-bit values:\"\n    var exponential_size = function exponential_size(n) {\n      if (n === 0) return 0;\n      if (n == 15) throw new Error(\"reserved value \".concat(n, \" in size\"));\n      return 1 << 6 + n;\n    };\n\n    var byte8 = buf.readUInt8(8);\n    info.submapper = byte8 & 0x0f;\n    info.mapper |= byte8 >> 4 << 8;\n    var byte9 = buf.readUInt8(9);\n    info.prg_rom_size |= (byte9 & 0x0f) << 8;\n    info.chr_rom_size |= (byte9 & 0xf0 >> 4) << 8;\n    var byte10 = buf.readUInt8(10);\n    info.prg_ram_not_battery_backed = exponential_size(byte10 & 0x0f);\n    info.prg_ram_is_battery_backed = exponential_size((byte10 & 0xf0) >> 4);\n    var byte11 = buf.readUInt8(11);\n    info.chr_ram_not_battery_backed = exponential_size(byte11 & 0x0f);\n    info.chr_ram_is_battery_backed = exponential_size((byte11 & 0xf0) >> 4);\n    var byte12 = buf.readUInt8(12);\n    info.tv_system = !!(byte12 & 1) ? 'PAL' : 'NTSC';\n    if (byte12 & 2) info.tv_system = 'both';\n    var byte13 = buf.readUInt8(13);\n    info.vs_ppu = ['RP2C03B', 'RP2C03G', 'RP2C04-0001', 'RP2C04-0002', 'RP2C04-0003', 'RP2C04-0004', 'RC2C03B', 'RC2C03C', 'RC2C05-01', 'RC2C05-02', 'RC2C05-03', 'RC2C05-04', 'RC2C05-05', 'not defined (13)', 'not defined (14)', 'not defined (15)'][byte13 & 0x0f];\n    info.vs_mode = (byte13 & 0xf0) >> 4;\n    var byte14 = buf.readUInt8(14);\n    info.extra_roms = byte14 & 3;\n    var byte15 = buf.readUInt8(15);\n    info.reserved15 = byte15;\n  }\n\n  info.header = buf.slice(0, 16);\n\n  if (info.has_trainer) {\n    info.trainer = buf.slice(16, 16 + 512);\n  }\n\n  var prg_start = 16 + (info.has_trainer ? 512 : 0);\n  info.prg_rom = buf.slice(prg_start, prg_start + info.prg_rom_size);\n\n  if (info.prg_rom.length !== info.prg_rom_size) {\n    throw new Error(\"PRG ROM bad read: \".concat(info.prg_rom.length, \" != \").concat(info.prg_rom_size));\n  }\n\n  var chr_start = prg_start + info.prg_rom_size;\n  info.chr_rom = buf.slice(chr_start, chr_start + info.chr_rom_size);\n\n  if (info.chr_rom.length !== info.chr_rom_size) {\n    throw new Error(\"CHR ROM bad read: \".concat(info.chr_rom.length, \" != \").concat(info.chr_rom_size));\n  } // PlayChoice INST-ROM and/or PROM and/or 128-byte or 127-byte title\n\n\n  info.trailer = buf.slice(chr_start + info.chr_rom_size);\n  return info;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (parseNES);\n\n//# sourceURL=webpack:///./src/lib/parseNes.js?");

/***/ }),

/***/ "./src/mappers/Mapper.js":
/*!*******************************!*\
  !*** ./src/mappers/Mapper.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Mapper = /*#__PURE__*/function () {\n  function Mapper(prgBanks, chrBanks) {\n    _classCallCheck(this, Mapper);\n\n    this.nPRGBanks = prgBanks;\n    this.nCHRBanks = chrBanks;\n    this.reset();\n  }\n\n  _createClass(Mapper, [{\n    key: \"cpuMapRead\",\n    value: function cpuMapRead(addr) {\n      return false;\n    }\n  }, {\n    key: \"cpuMapWrite\",\n    value: function cpuMapWrite(addr, data) {\n      return false;\n    }\n  }, {\n    key: \"ppuMapRead\",\n    value: function ppuMapRead(addr) {\n      // There is no mapping required for PPU\n      // PPU Address Bus          CHR ROM\n      // 0x0000 -> 0x1FFF: Map    0x0000 -> 0x1FFF\n      if (addr >= 0x0000 && addr <= 0x1FFF) {\n        return addr;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ppuMapWrite\",\n    value: function ppuMapWrite(addr) {\n      if (addr >= 0x0000 && addr <= 0x1FFF) {\n        if (this.nCHRBanks === 0) {\n          // Treat as RAM\n          return addr;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {}\n  }]);\n\n  return Mapper;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Mapper);\n\n//# sourceURL=webpack:///./src/mappers/Mapper.js?");

/***/ }),

/***/ "./src/mappers/Mapper000.js":
/*!**********************************!*\
  !*** ./src/mappers/Mapper000.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Mapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mapper */ \"./src/mappers/Mapper.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar Mapper000 = /*#__PURE__*/function (_Mapper) {\n  _inherits(Mapper000, _Mapper);\n\n  function Mapper000(prgBanks, chrBanks) {\n    var _this;\n\n    _classCallCheck(this, Mapper000);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Mapper000).call(this, prgBanks, chrBanks));\n\n    _this.reset();\n\n    return _this;\n  }\n\n  _createClass(Mapper000, [{\n    key: \"cpuMapRead\",\n    value: function cpuMapRead(addr) {\n      // if PRGROM is 16KB\n      //     CPU Address Bus          PRG ROM\n      //     0x8000 -> 0xBFFF: Map    0x0000 -> 0x3FFF\n      //     0xC000 -> 0xFFFF: Mirror 0x0000 -> 0x3FFF\n      // if PRGROM is 32KB\n      //     CPU Address Bus          PRG ROM\n      //     0x8000 -> 0xFFFF: Map    0x0000 -> 0x7FFF\n      if (addr >= 0x8000 && addr <= 0xFFFF) {\n        return addr & (this.nPRGBanks > 1 ? 0x7FFF : 0x3FFF);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"cpuMapWrite\",\n    value: function cpuMapWrite(addr, data) {\n      if (addr >= 0x8000 && addr <= 0xFFFF) {\n        return addr & (this.nPRGBanks > 1 ? 0x7FFF : 0x3FFF);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ppuMapRead\",\n    value: function ppuMapRead(addr) {\n      // There is no mapping required for PPU\n      // PPU Address Bus          CHR ROM\n      // 0x0000 -> 0x1FFF: Map    0x0000 -> 0x1FFF\n      if (addr >= 0x0000 && addr <= 0x1FFF) {\n        return addr;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ppuMapWrite\",\n    value: function ppuMapWrite(addr) {\n      if (addr >= 0x0000 && addr <= 0x1FFF) {\n        if (this.nCHRBanks === 0) {\n          // Treat as RAM\n          return addr;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {}\n  }]);\n\n  return Mapper000;\n}(_Mapper__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Mapper000);\n\n//# sourceURL=webpack:///./src/mappers/Mapper000.js?");

/***/ }),

/***/ "./src/mappers/Mapper001.js":
/*!**********************************!*\
  !*** ./src/mappers/Mapper001.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Mapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mapper */ \"./src/mappers/Mapper.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar Mapper001 = /*#__PURE__*/function (_Mapper) {\n  _inherits(Mapper001, _Mapper);\n\n  function Mapper001(prgBanks, chrBanks, mirrorMode) {\n    var _this;\n\n    _classCallCheck(this, Mapper001);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Mapper001).call(this, prgBanks, chrBanks));\n    _this.nCHRBankSelect4Lo = 0x00;\n    _this.nCHRBankSelect4Hi = 0x00;\n    _this.nCHRBankSelect8 = 0x00;\n    _this.nPRGBankSelect16Lo = 0x00;\n    _this.nPRGBankSelect16Hi = 0x00;\n    _this.nPRGBankSelect32 = 0x00;\n    _this.nLoadRegister = 0x00;\n    _this.nLoadRegisterCount = 0x00;\n    _this.nControlRegister = 0x00;\n    _this.mirrormode = mirrorMode;\n    _this.vRAMStatic = [];\n\n    _this.reset();\n\n    return _this;\n  }\n\n  _createClass(Mapper001, [{\n    key: \"cpuMapRead\",\n    value: function cpuMapRead(addr, data) {\n      if (addr >= 0x6000 && addr <= 0x7FFF) {\n        data.data = this.vRAMStatic[addr & 0x1FFF]; // Read is from static ram on cartridge\n\n        return 0xFFFFFFFF;\n      }\n\n      if (addr >= 0x8000) {\n        if (this.nControlRegister & 8) {\n          // 16K Mode\n          if (addr >= 0x8000 && addr <= 0xBFFF) {\n            return this.nPRGBankSelect16Lo * 0x4000 + (addr & 0x3FFF);\n          }\n\n          if (addr >= 0xC000 && addr <= 0xFFFF) {\n            return this.nPRGBankSelect16Hi * 0x4000 + (addr & 0x3FFF);\n          }\n        } else {\n          // 32K Mode\n          return this.nPRGBankSelect32 * 0x8000 + (addr & 0x7FFF);\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"cpuMapWrite\",\n    value: function cpuMapWrite(addr, data) {\n      if (addr >= 0x6000 && addr <= 0x7FFF) {\n        this.vRAMStatic[addr & 0x1FFF] = data; // Write is to static ram on cartridge\n\n        return 0xFFFFFFFF;\n      }\n\n      if (addr >= 0x8000) {\n        if (data & 0x80) {\n          // MSB is set, so reset serial loading\n          this.nLoadRegister = 0x00;\n          this.nLoadRegisterCount = 0;\n          this.nControlRegister = this.nControlRegister | 0x0C;\n        } else {\n          // Load data in serially into load register\n          // It arrives LSB first, so implant this at\n          // bit 5. After 5 writes, the register is ready\n          this.nLoadRegister >>= 1;\n          this.nLoadRegister |= (data & 0x01) << 4;\n          this.nLoadRegisterCount++;\n\n          if (this.nLoadRegisterCount === 5) {\n            // Get Mapper Target Register, by examining\n            // bits 13 & 14 of the address\n            var nTargetRegister = addr >> 13 & 0x03;\n\n            if (nTargetRegister === 0) // 0x8000 - 0x9FFF\n              {\n                // Set Control Register\n                this.nControlRegister = this.nLoadRegister & 0x1F;\n\n                switch (this.nControlRegister & 0x03) {\n                  case 0:\n                    this.mirrormode = Cartridge.ONESCREEN_LO;\n                    break;\n\n                  case 1:\n                    this.mirrormode = Cartridge.ONESCREEN_HI;\n                    break;\n\n                  case 2:\n                    this.mirrormode = Cartridge.VERTICAL;\n                    break;\n\n                  case 3:\n                    this.mirrormode = Cartridge.HORIZONTAL;\n                    break;\n                }\n              } else if (nTargetRegister === 1) // 0xA000 - 0xBFFF\n              {\n                // Set CHR Bank Lo\n                if (this.nControlRegister & 16) {\n                  // 4K CHR Bank at PPU 0x0000\n                  this.nCHRBankSelect4Lo = this.nLoadRegister & 0x1F;\n                } else {\n                  // 8K CHR Bank at PPU 0x0000\n                  this.nCHRBankSelect8 = this.nLoadRegister & 0x1E;\n                }\n              } else if (nTargetRegister === 2) // 0xC000 - 0xDFFF\n              {\n                // Set CHR Bank Hi\n                if (this.nControlRegister & 16) {\n                  // 4K CHR Bank at PPU 0x1000\n                  this.nCHRBankSelect4Hi = this.nLoadRegister & 0x1F;\n                }\n              } else if (nTargetRegister === 3) // 0xE000 - 0xFFFF\n              {\n                // Configure PRG Banks\n                var nPRGMode = this.nControlRegister >> 2 & 0x03;\n\n                if (nPRGMode === 0 || nPRGMode === 1) {\n                  // Set 32K PRG Bank at CPU 0x8000\n                  this.nPRGBankSelect32 = (this.nLoadRegister & 0x0E) >> 1;\n                } else if (nPRGMode === 2) {\n                  // Fix 16KB PRG Bank at CPU 0x8000 to First Bank\n                  this.nPRGBankSelect16Lo = 0; // Set 16KB PRG Bank at CPU 0xC000\n\n                  this.nPRGBankSelect16Hi = this.nLoadRegister & 0x0F;\n                } else if (nPRGMode === 3) {\n                  // Set 16KB PRG Bank at CPU 0x8000\n                  this.nPRGBankSelect16Lo = this.nLoadRegister & 0x0F; // Fix 16KB PRG Bank at CPU 0xC000 to Last Bank\n\n                  this.nPRGBankSelect16Hi = this.nPRGBanks - 1;\n                }\n              } // 5 bits were written, and decoded, so\n            // reset load register\n\n\n            this.nLoadRegister = 0x00;\n            this.nLoadRegisterCount = 0;\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ppuMapRead\",\n    value: function ppuMapRead(addr) {\n      if (addr < 0x2000) {\n        if (this.nCHRBanks === 0) {\n          return addr;\n        } else {\n          if (this.nControlRegister & 16) {\n            // 4K CHR Bank Mode\n            if (addr >= 0x0000 && addr <= 0x0FFF) {\n              return this.nCHRBankSelect4Lo * 0x1000 + (addr & 0x0FFF);\n            }\n\n            if (addr >= 0x1000 && addr <= 0x1FFF) {\n              return this.nCHRBankSelect4Hi * 0x1000 + (addr & 0x0FFF);\n            }\n          } else {\n            // 8K CHR Bank Mode\n            return this.nCHRBankSelect8 * 0x2000 + (addr & 0x1FFF);\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ppuMapWrite\",\n    value: function ppuMapWrite(addr) {\n      if (addr < 0x2000) {\n        if (this.nCHRBanks === 0) {\n          return addr;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.nControlRegister = 0x1C;\n      this.nLoadRegister = 0x00;\n      this.nLoadRegisterCount = 0x00;\n      this.nCHRBankSelect4Lo = 0;\n      this.nCHRBankSelect4Hi = 0;\n      this.nCHRBankSelect8 = 0;\n      this.nPRGBankSelect32 = 0;\n      this.nPRGBankSelect16Lo = 0;\n      this.nPRGBankSelect16Hi = this.nPRGBanks - 1;\n    }\n  }]);\n\n  return Mapper001;\n}(_Mapper__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Mapper001);\n\n//# sourceURL=webpack:///./src/mappers/Mapper001.js?");

/***/ }),

/***/ "./src/mappers/Mapper002.js":
/*!**********************************!*\
  !*** ./src/mappers/Mapper002.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Mapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mapper */ \"./src/mappers/Mapper.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar Mapper002 = /*#__PURE__*/function (_Mapper) {\n  _inherits(Mapper002, _Mapper);\n\n  function Mapper002(prgBanks, chrBanks) {\n    var _this;\n\n    _classCallCheck(this, Mapper002);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Mapper002).call(this, prgBanks, chrBanks));\n    _this.nPRGBankSelectLo = 1;\n    _this.nPRGBankSelectHi = prgBanks - 1;\n\n    _this.reset();\n\n    return _this;\n  }\n\n  _createClass(Mapper002, [{\n    key: \"cpuMapRead\",\n    value: function cpuMapRead(addr) {\n      if (addr >= 0x8000 && addr <= 0xBFFF) {\n        return this.nPRGBankSelectLo * 0x4000 + (addr & 0x3FFF);\n      }\n\n      if (addr >= 0xC000 && addr <= 0xFFFF) {\n        return this.nPRGBankSelectHi * 0x4000 + (addr & 0x3FFF);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"cpuMapWrite\",\n    value: function cpuMapWrite(addr, data) {\n      if (addr >= 0x8000 && addr <= 0xFFFF) {\n        this.nPRGBankSelectLo = data & 0x0F;\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ppuMapRead\",\n    value: function ppuMapRead(addr) {\n      // There is no mapping required for PPU\n      // PPU Address Bus          CHR ROM\n      // 0x0000 -> 0x1FFF: Map    0x0000 -> 0x1FFF\n      if (addr < 0x2000) {\n        if (this.nCHRBanks === 0) // Treating as RAM\n          {\n            return addr;\n          }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ppuMapWrite\",\n    value: function ppuMapWrite(addr) {\n      if (addr < 0x2000) {\n        if (this.nCHRBanks === 0) // Treating as RAM\n          {\n            return addr;\n          }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.nPRGBankSelectLo = 1;\n      this.nPRGBankSelectHi = this.nPRGBanks - 1;\n    }\n  }]);\n\n  return Mapper002;\n}(_Mapper__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Mapper002);\n\n//# sourceURL=webpack:///./src/mappers/Mapper002.js?");

/***/ }),

/***/ "./src/olc2C02.js":
/*!************************!*\
  !*** ./src/olc2C02.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_Sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/Sprite */ \"./src/lib/Sprite.js\");\n/* harmony import */ var _lib_Struct__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/Struct */ \"./src/lib/Struct.js\");\n/* harmony import */ var _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/PIxel */ \"./src/lib/PIxel.js\");\n/* harmony import */ var _Cartridge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Cartridge */ \"./src/Cartridge.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar olc2C02 = /*#__PURE__*/function () {\n  function olc2C02(canvas) {\n    _classCallCheck(this, olc2C02);\n\n    this.vram_addr = null; // Active \"pointer\" address into nametable to extract background tile info\n\n    this.tram_addr = {}; // Temporary store of information to be \"transferred\" into \"pointer\" at various times\n    // Pixel offset horizontally\n\n    this.fine_x = 0x00; // Internal communications\n\n    this.address_latch = 0x00;\n    this.ppu_data_buffer = 0xFF; // Pixel \"dot\" position information\n\n    this.scanline = 0;\n    this.cycle = 0;\n    this.status = new _lib_Struct__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n      unused: 5,\n      sprite_overflow: 1,\n      sprite_zero_hit: 1,\n      vertical_blank: 1\n    });\n    this.mask = new _lib_Struct__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n      grayscale: 1,\n      render_background_left: 1,\n      render_sprites_left: 1,\n      render_background: 1,\n      render_sprites: 1,\n      enhance_red: 1,\n      enhance_green: 1,\n      enhance_blue: 1\n      /*\n      reg: () => {\n      \treturn 0x00000000\n      \t\t| (this.status.grayscale << 1) | (this.status.render_background_left << 2)\n      \t\t| (this.status.render_sprites_left << 3) | (this.status.render_background << 4)\n      \t\t| (this.status.render_sprites << 5) | (this.status.enhance_red << 6)\n      \t\t| (this.status.enhance_green << 7) | (this.status.enhance_blue << 8);\n      }*/\n\n    });\n    this.control = new _lib_Struct__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n      nametable_x: 1,\n      nametable_y: 1,\n      increment_mode: 1,\n      pattern_sprite: 1,\n      pattern_background: 1,\n      sprite_size: 1,\n      slave_mode: 1,\n      // unused\n      enable_nmi: 1\n      /*\n      reg: () => {\n      return 0x00000000\n      | (this.status.nametable_x << 1) | (this.status.nametable_y << 2)\n      | (this.status.increment_mode << 3) | (this.status.pattern_sprite << 4)\n      | (this.status.pattern_background << 5) | (this.status.sprite_size << 6)\n      | (this.status.slave_mode << 7) | (this.status.enable_nmi << 8);\n      }*/\n\n    });\n    this.vram_addr = new _lib_Struct__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n      coarse_x: 5,\n      coarse_y: 5,\n      nametable_x: 1,\n      nametable_y: 1,\n      fine_y: 3,\n      unused: 1\n    });\n    this.tram_addr = new _lib_Struct__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n      coarse_x: 5,\n      coarse_y: 5,\n      nametable_x: 1,\n      nametable_y: 1,\n      fine_y: 3,\n      unused: 1\n    });\n    this.OAM = Array(65);\n\n    for (var i = 0; i < 65; i++) {\n      this.OAM[i] = {};\n    } // Background rendering =========================================\n\n\n    this.bg_next_tile_id = 0x00;\n    this.bg_next_tile_attrib = 0x00;\n    this.bg_next_tile_lsb = 0x00;\n    this.bg_next_tile_msb = 0x00;\n    this.bg_shifter_pattern_lo = 0x0000;\n    this.bg_shifter_pattern_hi = 0x0000;\n    this.bg_shifter_attrib_lo = 0x0000;\n    this.bg_shifter_attrib_hi = 0x0000;\n    this.tblName = [Array(4096).fill(0x00), Array(4096).fill(0x00)];\n    this.tblPattern = [Array(4096).fill(0x00), Array(4096).fill(0x00)];\n    this.tblPalette = [];\n    var palScreen = [];\n    this.sprScreen = new _lib_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas, 370, 240);\n    this.sprNameTable = [new _lib_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas, 256, 240), new _lib_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas, 256, 240)];\n    this.sprPatternTable = [new _lib_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas, 128, 128), new _lib_Sprite__WEBPACK_IMPORTED_MODULE_0__[\"default\"](canvas, 128, 128)];\n    palScreen[0x00] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](84, 84, 84);\n    palScreen[0x01] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 30, 116);\n    palScreen[0x02] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](8, 16, 144);\n    palScreen[0x03] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](48, 0, 136);\n    palScreen[0x04] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](68, 0, 100);\n    palScreen[0x05] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](92, 0, 48);\n    palScreen[0x06] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](84, 4, 0);\n    palScreen[0x07] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](60, 24, 0);\n    palScreen[0x08] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](32, 42, 0);\n    palScreen[0x09] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](8, 58, 0);\n    palScreen[0x0A] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 64, 0);\n    palScreen[0x0B] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 60, 0);\n    palScreen[0x0C] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 50, 60);\n    palScreen[0x0D] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    palScreen[0x0E] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    palScreen[0x0F] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    palScreen[0x10] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](152, 150, 152);\n    palScreen[0x11] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](8, 76, 196);\n    palScreen[0x12] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](48, 50, 236);\n    palScreen[0x13] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](92, 30, 228);\n    palScreen[0x14] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](136, 20, 176);\n    palScreen[0x15] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](160, 20, 100);\n    palScreen[0x16] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](152, 34, 32);\n    palScreen[0x17] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](120, 60, 0);\n    palScreen[0x18] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](84, 90, 0);\n    palScreen[0x19] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](40, 114, 0);\n    palScreen[0x1A] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](8, 124, 0);\n    palScreen[0x1B] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 118, 40);\n    palScreen[0x1C] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 102, 120);\n    palScreen[0x1D] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    palScreen[0x1E] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    palScreen[0x1F] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    palScreen[0x20] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](236, 238, 236);\n    palScreen[0x21] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](76, 154, 236);\n    palScreen[0x22] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](120, 124, 236);\n    palScreen[0x23] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](176, 98, 236);\n    palScreen[0x24] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](228, 84, 236);\n    palScreen[0x25] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](236, 88, 180);\n    palScreen[0x26] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](236, 106, 100);\n    palScreen[0x27] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](212, 136, 32);\n    palScreen[0x28] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](160, 170, 0);\n    palScreen[0x29] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](116, 196, 0);\n    palScreen[0x2A] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](76, 208, 32);\n    palScreen[0x2B] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](56, 204, 108);\n    palScreen[0x2C] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](56, 180, 204);\n    palScreen[0x2D] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](60, 60, 60);\n    palScreen[0x2E] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    palScreen[0x2F] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    palScreen[0x30] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](236, 238, 236);\n    palScreen[0x31] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](168, 204, 236);\n    palScreen[0x32] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](188, 188, 236);\n    palScreen[0x33] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](212, 178, 236);\n    palScreen[0x34] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](236, 174, 236);\n    palScreen[0x35] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](236, 174, 212);\n    palScreen[0x36] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](236, 180, 176);\n    palScreen[0x37] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](228, 196, 144);\n    palScreen[0x38] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](204, 210, 120);\n    palScreen[0x39] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](180, 222, 120);\n    palScreen[0x3A] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](168, 226, 144);\n    palScreen[0x3B] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](152, 226, 180);\n    palScreen[0x3C] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](160, 214, 228);\n    palScreen[0x3D] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](160, 162, 160);\n    palScreen[0x3E] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    palScreen[0x3F] = new _lib_PIxel__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, 0, 0);\n    this.palScreen = palScreen;\n    this.oam_addr = 0x00;\n    this.spriteScanline = Array(8);\n\n    for (var _i = 0; _i < 8; _i++) {\n      this.spriteScanline[_i] = {};\n    }\n\n    this.sprite_count = 0;\n    this.sprite_shifter_pattern_lo = [];\n    this.sprite_shifter_pattern_hi = []; // Sprite Zero Collision Flags\n\n    this.bSpriteZeroHitPossible = false;\n    this.bSpriteZeroBeingRendered = false;\n    this.frame_complete = false;\n  }\n\n  _createClass(olc2C02, [{\n    key: \"ConnectBus\",\n    value: function ConnectBus(bus) {\n      this.bus = bus;\n      bus.ppu = this;\n    }\n  }, {\n    key: \"GetScreen\",\n    value: function GetScreen() {\n      // Simply returns the current sprite holding the rendered screen\n      return this.sprScreen;\n    }\n  }, {\n    key: \"GetPatternTable\",\n    value: function GetPatternTable(i, palette) {\n      // This function draw the CHR ROM for a given pattern table into\n      // an olc::Sprite, using a specified palette. Pattern tables consist\n      // of 16x16 \"tiles or characters\". It is independent of the running\n      // emulation and using it does not change the systems state, though\n      // it gets all the data it needs from the live system. Consequently,\n      // if the game has not yet established palettes or mapped to relevant\n      // CHR ROM banks, the sprite may look empty. This approach permits a\n      // \"live\" extraction of the pattern table exactly how the NES, and\n      // ultimately the player would see it.\n      // A tile consists of 8x8 pixels. On the NES, pixels are 2 bits, which\n      // gives an index into 4 different colours of a specific palette. There\n      // are 8 palettes to choose from. Colour \"0\" in each palette is effectively\n      // considered transparent, as those locations in memory \"mirror\" the global\n      // background colour being used. This mechanics of this are shown in\n      // detail in ppuRead() & ppuWrite()\n      // Characters on NES\n      // ~~~~~~~~~~~~~~~~~\n      // The NES stores characters using 2-bit pixels. These are not stored sequentially\n      // but in singular bit planes. For example:\n      //\n      // 2-Bit Pixels       LSB Bit Plane     MSB Bit Plane\n      // 0 0 0 0 0 0 0 0\t  0 0 0 0 0 0 0 0   0 0 0 0 0 0 0 0\n      // 0 1 1 0 0 1 1 0\t  0 1 1 0 0 1 1 0   0 0 0 0 0 0 0 0\n      // 0 1 2 0 0 2 1 0\t  0 1 1 0 0 1 1 0   0 0 1 0 0 1 0 0\n      // 0 0 0 0 0 0 0 0 =  0 0 0 0 0 0 0 0 + 0 0 0 0 0 0 0 0\n      // 0 1 1 0 0 1 1 0\t  0 1 1 0 0 1 1 0   0 0 0 0 0 0 0 0\n      // 0 0 1 1 1 1 0 0\t  0 0 1 1 1 1 0 0   0 0 0 0 0 0 0 0\n      // 0 0 0 2 2 0 0 0\t  0 0 0 1 1 0 0 0   0 0 0 1 1 0 0 0\n      // 0 0 0 0 0 0 0 0\t  0 0 0 0 0 0 0 0   0 0 0 0 0 0 0 0\n      //\n      // The planes are stored as 8 bytes of LSB, followed by 8 bytes of MSB\n      // Loop through all 16x16 tiles\n      for (var nTileY = 0; nTileY < 16; nTileY++) {\n        for (var nTileX = 0; nTileX < 16; nTileX++) {\n          // Convert the 2D tile coordinate into a 1D offset into the pattern\n          // table memory.\n          var nOffset = nTileY * 256 + nTileX * 16; // Now loop through 8 rows of 8 pixels\n\n          for (var row = 0; row < 8; row++) {\n            // For each row, we need to read both bit planes of the character\n            // in order to extract the least significant and most significant\n            // bits of the 2 bit pixel value. in the CHR ROM, each character\n            // is stored as 64 bits of lsb, followed by 64 bits of msb. This\n            // conveniently means that two corresponding rows are always 8\n            // bytes apart in memory.\n            var tile_lsb = this.ppuRead(i * 0x1000 + nOffset + row + 0x0000);\n            var tile_msb = this.ppuRead(i * 0x1000 + nOffset + row + 0x0008); // Now we have a single row of the two bit planes for the character\n            // we need to iterate through the 8-bit words, combining them to give\n            // us the final pixel index\n\n            for (var col = 0; col < 8; col++) {\n              // We can get the index value by simply adding the bits together\n              // but we're only interested in the lsb of the row words because...\n              var pixel = (tile_lsb & 0x01) << 1 | tile_msb & 0x01; // ...we will shift the row words 1 bit right for each column of\n              // the character.\n\n              tile_lsb >>= 1;\n              tile_msb >>= 1; // Now we know the location and NES pixel value for a specific location\n              // in the pattern table, we can translate that to a screen colour, and an\n              // (x,y) location in the sprite\n\n              this.sprPatternTable[i].SetPixel(nTileX * 8 + (7 - col), // Because we are using the lsb of the row word first\n              // we are effectively reading the row from right\n              // to left, so we need to draw the row \"backwards\"\n              nTileY * 8 + row, this.GetColourFromPaletteRam(palette, pixel));\n            }\n          }\n        }\n      } // Finally return the updated sprite representing the pattern table\n\n\n      return this.sprPatternTable[i];\n    }\n  }, {\n    key: \"GetColourFromPaletteRam\",\n    value: function GetColourFromPaletteRam(palette, pixel) {\n      // This is a convenience function that takes a specified palette and pixel\n      // index and returns the appropriate screen colour.\n      // \"0x3F00\"       - Offset into PPU addressable range where palettes are stored\n      // \"palette << 2\" - Each palette is 4 bytes in size\n      // \"pixel\"        - Each pixel index is either 0, 1, 2 or 3\n      // \"& 0x3F\"       - Stops us reading beyond the bounds of the palScreen array\n      return this.palScreen[this.ppuRead(0x3F00 + (palette << 2) + pixel) & 0x3F]; // Note: We dont access tblPalette directly here, instead we know that ppuRead()\n      // will map the address onto the seperate small RAM attached to the PPU bus.\n    }\n  }, {\n    key: \"GetNameTable\",\n    value: function GetNameTable(i) {\n      // As of now unused, but a placeholder for nametable visualisation in teh future\n      return this.sprNameTable[i];\n    }\n  }, {\n    key: \"cpuRead\",\n    value: function cpuRead(addr, rdonly) {\n      var data = 0x00;\n\n      if (rdonly) {\n        // Reading from PPU registers can affect their contents\n        // so this read only option is used for examining the\n        // state of the PPU without changing its state. This is\n        // really only used in debug mode.\n        switch (addr) {\n          case 0x0000:\n            // Control\n            data = this.control.reg;\n            break;\n\n          case 0x0001:\n            // Mask\n            data = this.mask.reg;\n            break;\n\n          case 0x0002:\n            // Status\n            data = this.status.reg;\n            break;\n\n          case 0x0003:\n            // OAM Address\n            break;\n\n          case 0x0004:\n            // OAM Data\n            break;\n\n          case 0x0005:\n            // Scroll\n            break;\n\n          case 0x0006:\n            // PPU Address\n            break;\n\n          case 0x0007:\n            // PPU Data\n            break;\n        }\n      } else {\n        // These are the live PPU registers that repsond\n        // to being read from in various ways. Note that not\n        // all the registers are capable of being read from\n        // so they just return 0x00\n        switch (addr) {\n          // Control - Not readable\n          case 0x0000:\n            break;\n          // Mask - Not Readable\n\n          case 0x0001:\n            break;\n          // Status\n\n          case 0x0002:\n            // Reading from the status register has the effect of resetting\n            // different parts of the circuit. Only the top three bits\n            // contain status information, however it is possible that\n            // some \"noise\" gets picked up on the bottom 5 bits which\n            // represent the last PPU bus transaction. Some games \"may\"\n            // use this noise as valid data (even though they probably\n            // shouldn't)\n            data = this.status.reg & 0xE0 | this.ppu_data_buffer & 0x1F; // Clear the vertical blanking flag\n\n            this.status.vertical_blank = 0; // Reset Loopy's Address latch flag\n\n            this.address_latch = 0;\n            break;\n          // OAM Address - Not Readable\n\n          case 0x0003:\n            break;\n          // OAM Data\n\n          case 0x0004:\n            var oam_addr = Math.floor(this.oam_addr / 4);\n            var i = this.oam_addr % 4;\n\n            if (i === 0) {\n              data = this.OAM[oam_addr].y;\n            } else if (i === 1) {\n              data = this.OAM[oam_addr].id;\n            } else if (i === 2) {\n              data = this.OAM[oam_addr].attribute;\n            } else {\n              data = this.OAM[oam_addr].x;\n            }\n\n            break;\n          // Scroll - Not Readable\n\n          case 0x0005:\n            break;\n          // PPU Address - Not Readable\n\n          case 0x0006:\n            break;\n          // PPU Data\n\n          case 0x0007:\n            // Reads from the NameTable ram get delayed one cycle,\n            // so output buffer which contains the data from the\n            // previous read request\n            data = this.ppu_data_buffer; // then update the buffer for next time\n\n            this.ppu_data_buffer = this.ppuRead(this.vram_addr.reg); // However, if the address was in the palette range, the\n            // data is not delayed, so it returns immediately\n\n            if (this.vram_addr.reg >= 0x3F00) data = this.ppu_data_buffer; // All reads from PPU data automatically increment the nametable\n            // address depending upon the mode set in the control register.\n            // If set to vertical mode, the increment is 32, so it skips\n            // one whole nametable row; in horizontal mode it just increments\n            // by 1, moving to the next column\n\n            this.vram_addr.reg = this.vram_addr.reg + (this.control.increment_mode ? 32 : 1);\n            break;\n        }\n      }\n\n      return data;\n    }\n  }, {\n    key: \"OAMWrite\",\n    value: function OAMWrite(addr, data) {\n      var oam_addr = Math.floor(addr / 4);\n      var i = addr % 4;\n\n      if (i === 0) {\n        this.OAM[oam_addr].y = data;\n      } else if (i === 1) {\n        this.OAM[oam_addr].id = data;\n      } else if (i === 2) {\n        this.OAM[oam_addr].attribute = data;\n      } else {\n        this.OAM[oam_addr].x = data;\n      }\n    }\n  }, {\n    key: \"cpuWrite\",\n    value: function cpuWrite(addr, data) {\n      switch (addr) {\n        case 0x0000:\n          // Control\n          this.control.reg = data;\n          this.tram_addr.nametable_x = this.control.nametable_x ? 1 : 0;\n          this.tram_addr.nametable_y = this.control.nametable_y ? 1 : 0;\n          break;\n\n        case 0x0001:\n          // Mask\n          this.mask.reg = data;\n          break;\n\n        case 0x0002:\n          // Status\n          break;\n\n        case 0x0003:\n          // OAM Address\n          this.oam_addr = data;\n          break;\n\n        case 0x0004:\n          // OAM Data\n          this.OAMWrite(this.oam_addr, data);\n          break;\n\n        case 0x0005:\n          // Scroll\n          if (this.address_latch === 0) {\n            // First write to scroll register contains X offset in pixel space\n            // which we split into coarse and fine x values\n            this.fine_x = data & 0x07;\n            this.tram_addr.coarse_x = data >> 3;\n            this.address_latch = 1;\n          } else {\n            // First write to scroll register contains Y offset in pixel space\n            // which we split into coarse and fine Y values\n            this.tram_addr.fine_y = data & 0x07;\n            this.tram_addr.coarse_y = data >> 3;\n            this.address_latch = 0;\n          }\n\n          break;\n\n        case 0x0006:\n          // PPU Address\n          if (this.address_latch === 0) {\n            // PPU address bus can be accessed by CPU via the ADDR and DATA\n            // registers. The first write to this register latches the high byte\n            // of the address, the second is the low byte. Note the writes\n            // are stored in the tram register...\n            this.tram_addr.reg = (data & 0x3F) << 8 | this.tram_addr.reg & 0x00FF;\n            this.address_latch = 1;\n          } else {\n            // ...when a whole address has been written, the internal vram address\n            // buffer is updated. Writing to the PPU is unwise during rendering\n            // as the PPU will maintam the vram address automatically whilst\n            // rendering the scanline position.\n            this.tram_addr.reg = this.tram_addr.reg & 0xFF00 | data;\n            this.vram_addr.reg = this.tram_addr.reg;\n            this.address_latch = 0;\n          }\n\n          break;\n\n        case 0x0007:\n          // PPU Data\n          this.ppuWrite(this.vram_addr.reg, data); // All writes from PPU data automatically increment the nametable\n          // address depending upon the mode set in the control register.\n          // If set to vertical mode, the increment is 32, so it skips\n          // one whole nametable row; in horizontal mode it just increments\n          // by 1, moving to the next column\n\n          this.vram_addr.reg = this.vram_addr.reg + (this.control.increment_mode ? 32 : 1);\n          break;\n      }\n    }\n  }, {\n    key: \"ppuRead\",\n    value: function ppuRead(addr, rdonly) {\n      var data = 0x00;\n      addr &= 0x3FFF;\n      var temp = this.bus.cart.ppuRead(addr, data);\n\n      if (temp !== false) {\n        data = temp;\n      } else if (addr >= 0x0000 && addr <= 0x1FFF) {\n        // If the cartridge cant map the addrestpls, have\n        // a physical location ready here\n        data = this.tblPattern[(addr & 0x1000) >> 12][addr & 0x0FFF];\n      } else if (addr >= 0x2000 && addr <= 0x3EFF) {\n        addr &= 0x0FFF;\n\n        if (this.cart.mirror === _Cartridge__WEBPACK_IMPORTED_MODULE_3__[\"default\"].VERTICAL) {\n          // Vertical\n          if (addr >= 0x0000 && addr <= 0x03FF) data = this.tblName[0][addr & 0x03FF];\n          if (addr >= 0x0400 && addr <= 0x07FF) data = this.tblName[1][addr & 0x03FF];\n          if (addr >= 0x0800 && addr <= 0x0BFF) data = this.tblName[0][addr & 0x03FF];\n          if (addr >= 0x0C00 && addr <= 0x0FFF) data = this.tblName[1][addr & 0x03FF];\n        } else {\n          // Horizontal\n          if (addr >= 0x0000 && addr <= 0x03FF) data = this.tblName[0][addr & 0x03FF];\n          if (addr >= 0x0400 && addr <= 0x07FF) data = this.tblName[0][addr & 0x03FF];\n          if (addr >= 0x0800 && addr <= 0x0BFF) data = this.tblName[1][addr & 0x03FF];\n          if (addr >= 0x0C00 && addr <= 0x0FFF) data = this.tblName[1][addr & 0x03FF];\n        }\n      } else if (addr >= 0x3F00 && addr <= 0x3FFF) {\n        addr &= 0x001F;\n        if (addr === 0x0010) addr = 0x0000;\n        if (addr === 0x0014) addr = 0x0004;\n        if (addr === 0x0018) addr = 0x0008;\n        if (addr === 0x001C) addr = 0x000C;\n        data = this.tblPalette[addr] & (this.mask.grayscale ? 0x30 : 0x3F);\n      }\n\n      return data || 0;\n    }\n  }, {\n    key: \"ppuWrite\",\n    value: function ppuWrite(addr, data) {\n      addr &= 0x3FFF;\n\n      if (this.cart.ppuWrite(addr, data)) {} else if (addr >= 0x0000 && addr <= 0x1FFF) {\n        this.tblPattern[(addr & 0x1000) >> 12][addr & 0x0FFF] = data;\n      } else if (addr >= 0x2000 && addr <= 0x3EFF) {\n        addr &= 0x0FFF;\n\n        if (this.cart.mirror === _Cartridge__WEBPACK_IMPORTED_MODULE_3__[\"default\"].VERTICAL) {\n          // Vertical\n          if (addr >= 0x0000 && addr <= 0x03FF) this.tblName[0][addr & 0x03FF] = data;\n          if (addr >= 0x0400 && addr <= 0x07FF) this.tblName[1][addr & 0x03FF] = data;\n          if (addr >= 0x0800 && addr <= 0x0BFF) this.tblName[0][addr & 0x03FF] = data;\n          if (addr >= 0x0C00 && addr <= 0x0FFF) this.tblName[1][addr & 0x03FF] = data;\n        } else {\n          // Horizontal\n          if (addr >= 0x0000 && addr <= 0x03FF) this.tblName[0][addr & 0x03FF] = data;\n          if (addr >= 0x0400 && addr <= 0x07FF) this.tblName[0][addr & 0x03FF] = data;\n          if (addr >= 0x0800 && addr <= 0x0BFF) this.tblName[1][addr & 0x03FF] = data;\n          if (addr >= 0x0C00 && addr <= 0x0FFF) this.tblName[1][addr & 0x03FF] = data;\n        }\n      } else if (addr >= 0x3F00 && addr <= 0x3FFF) {\n        addr &= 0x001F;\n        if (addr === 0x0010) addr = 0x0000;\n        if (addr === 0x0014) addr = 0x0004;\n        if (addr === 0x0018) addr = 0x0008;\n        if (addr === 0x001C) addr = 0x000C;\n        this.tblPalette[addr] = data;\n      }\n    }\n  }, {\n    key: \"ConnectCartridge\",\n    value: function ConnectCartridge(cartridge) {\n      this.cart = cartridge;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.fine_x = 0x00;\n      this.address_latch = 0x00;\n      this.ppu_data_buffer = 0x00;\n      this.scanline = 0;\n      this.cycle = 0;\n      this.bg_next_tile_id = 0x00;\n      this.bg_next_tile_attrib = 0x00;\n      this.bg_next_tile_lsb = 0x00;\n      this.bg_next_tile_msb = 0x00;\n      this.bg_shifter_pattern_lo = 0x0000;\n      this.bg_shifter_pattern_hi = 0x0000;\n      this.bg_shifter_attrib_lo = 0x0000;\n      this.bg_shifter_attrib_hi = 0x0000;\n      this.status.reg = 0x00;\n      this.mask.reg = 0x00;\n      this.control.reg = 0x00;\n      this.vram_addr.reg = 0x0000;\n      this.tram_addr.reg = 0x0000;\n    }\n  }, {\n    key: \"clock\",\n    value: function clock() {\n      var _this = this;\n\n      // As we progress through scanlines and cycles, the PPU is effectively\n      // a state machine going through the motions of fetching background\n      // information and sprite information, compositing them into a pixel\n      // to be output.\n      // The lambda functions (functions inside functions) contain the various\n      // actions to be performed depending upon the output of the state machine\n      // for a given scanline/cycle combination\n      // ==============================================================================\n      // Increment the background tile \"pointer\" one tile/column horizontally\n      var IncrementScrollX = function IncrementScrollX() {\n        // Note: pixel perfect scrolling horizontally is handled by the\n        // data shifters. Here we are operating in the spatial domain of\n        // tiles, 8x8 pixel blocks.\n        // Ony if rendering is enabled\n        if (_this.mask.render_background || _this.mask.render_sprites) {\n          // A single name table is 32x30 tiles. As we increment horizontally\n          // we may cross into a neighbouring nametable, or wrap around to\n          // a neighbouring nametable\n          if (_this.vram_addr.coarse_x === 31) {\n            // Leaving nametable so wrap address round\n            _this.vram_addr.coarse_x = 0; // Flip target nametable bit\n\n            _this.vram_addr.nametable_x = _this.vram_addr.nametable_x ? 0 : 1;\n          } else {\n            // Staying in current nametable, so just increment\n            _this.vram_addr.coarse_x++;\n          }\n        }\n      }; // ==============================================================================\n      // Increment the background tile \"pointer\" one scanline vertically\n\n\n      var IncrementScrollY = function IncrementScrollY() {\n        // Incrementing vertically is more complicated. The visible nametable\n        // is 32x30 tiles, but in memory there is enough room for 32x32 tiles.\n        // The bottom two rows of tiles are in fact not tiles at all, they\n        // contain the \"attribute\" information for the entire table. This is\n        // information that describes which palettes are used for different\n        // regions of the nametable.\n        // In addition, the NES doesnt scroll vertically in chunks of 8 pixels\n        // i.e. the height of a tile, it can perform fine scrolling by using\n        // the fine_y component of the register. This means an increment in Y\n        // first adjusts the fine offset, but may need to adjust the whole\n        // row offset, since fine_y is a value 0 to 7, and a row is 8 pixels high\n        // Ony if rendering is enabled\n        if (_this.mask.render_background || _this.mask.render_sprites) {\n          // If possible, just increment the fine y offset\n          if (_this.vram_addr.fine_y < 7) {\n            _this.vram_addr.fine_y++;\n          } else {\n            // If we have gone beyond the height of a row, we need to\n            // increment the row, potentially wrapping into neighbouring\n            // vertical nametables. Dont forget however, the bottom two rows\n            // do not contain tile information. The coarse y offset is used\n            // to identify which row of the nametable we want, and the fine\n            // y offset is the specific \"scanline\"\n            // Reset fine y offset\n            _this.vram_addr.fine_y = 0; // Check if we need to swap vertical nametable targets\n\n            if (_this.vram_addr.coarse_y === 29) {\n              // We do, so reset coarse y offset\n              _this.vram_addr.coarse_y = 0; // And flip the target nametable bit\n\n              _this.vram_addr.nametable_y = _this.vram_addr.nametable_y ? 0 : 1;\n            } else if (_this.vram_addr.coarse_y === 31) {\n              // In case the pointer is in the attribute memory, we\n              // just wrap around the current nametable\n              _this.vram_addr.coarse_y = 0;\n            } else {\n              // None of the above boundary/wrapping conditions apply\n              // so just increment the coarse y offset\n              _this.vram_addr.coarse_y++;\n            }\n          }\n        }\n      }; // ==============================================================================\n      // Transfer the temporarily stored horizontal nametable access information\n      // into the \"pointer\". Note that fine x scrolling is not part of the \"pointer\"\n      // addressing mechanism\n\n\n      var TransferAddressX = function TransferAddressX() {\n        // Ony if rendering is enabled\n        if (_this.mask.render_background || _this.mask.render_sprites) {\n          _this.vram_addr.nametable_x = _this.tram_addr.nametable_x;\n          _this.vram_addr.coarse_x = _this.tram_addr.coarse_x;\n        }\n      }; // ==============================================================================\n      // Transfer the temporarily stored vertical nametable access information\n      // into the \"pointer\". Note that fine y scrolling is part of the \"pointer\"\n      // addressing mechanism\n\n\n      var TransferAddressY = function TransferAddressY() {\n        // Ony if rendering is enabled\n        if (_this.mask.render_background || _this.mask.render_sprites) {\n          _this.vram_addr.fine_y = _this.tram_addr.fine_y;\n          _this.vram_addr.nametable_y = _this.tram_addr.nametable_y;\n          _this.vram_addr.coarse_y = _this.tram_addr.coarse_y;\n        }\n      }; // ==============================================================================\n      // Prime the \"in-effect\" background tile shifters ready for outputting next\n      // 8 pixels in scanline.\n\n\n      var LoadBackgroundShifters = function LoadBackgroundShifters() {\n        // Each PPU update we calculate one pixel. These shifters shift 1 bit along\n        // feeding the pixel compositor with the binary information it needs. Its\n        // 16 bits wide, because the top 8 bits are the current 8 pixels being drawn\n        // and the bottom 8 bits are the next 8 pixels to be drawn. Naturally this means\n        // the required bit is always the MSB of the shifter. However, \"fine x\" scrolling\n        // plays a part in this too, whcih is seen later, so in fact we can choose\n        // any one of the top 8 bits.\n        _this.bg_shifter_pattern_lo = _this.bg_shifter_pattern_lo & 0xFF00 | _this.bg_next_tile_lsb;\n        _this.bg_shifter_pattern_hi = _this.bg_shifter_pattern_hi & 0xFF00 | _this.bg_next_tile_msb; // Attribute bits do not change per pixel, rather they change every 8 pixels\n        // but are synchronised with the pattern shifters for convenience, so here\n        // we take the bottom 2 bits of the attribute word which represent which\n        // palette is being used for the current 8 pixels and the next 8 pixels, and\n        // \"inflate\" them to 8 bit words.\n\n        _this.bg_shifter_attrib_lo = _this.bg_shifter_attrib_lo & 0xFF00 | (_this.bg_next_tile_attrib & 1 ? 0xFF : 0x00);\n        _this.bg_shifter_attrib_hi = _this.bg_shifter_attrib_hi & 0xFF00 | (_this.bg_next_tile_attrib & 2 ? 0xFF : 0x00);\n      }; // ==============================================================================\n      // Every cycle the shifters storing pattern and attribute information shift\n      // their contents by 1 bit. This is because every cycle, the output progresses\n      // by 1 pixel. This means relatively, the state of the shifter is in sync\n      // with the pixels being drawn for that 8 pixel section of the scanline.\n\n\n      var UpdateShifters = function UpdateShifters() {\n        if (_this.mask.render_background) {\n          // Shifting background tile pattern row\n          _this.bg_shifter_pattern_lo = _this.bg_shifter_pattern_lo << 1 & 0xFFFF;\n          _this.bg_shifter_pattern_hi = _this.bg_shifter_pattern_hi << 1 & 0xFFFF; // Shifting palette attributes by 1\n\n          _this.bg_shifter_attrib_lo = _this.bg_shifter_attrib_lo << 1 & 0xFFFF;\n          _this.bg_shifter_attrib_hi = _this.bg_shifter_attrib_hi << 1 & 0xFFFF;\n        }\n\n        if (_this.mask.render_sprites && _this.cycle >= 1 && _this.cycle < 258) {\n          for (var i = 0; i < _this.sprite_count; i++) {\n            if (_this.spriteScanline[i].x > 0) {\n              _this.spriteScanline[i].x--;\n            } else {\n              _this.sprite_shifter_pattern_lo[i] = _this.sprite_shifter_pattern_lo[i] << 1 & 0xFF;\n              _this.sprite_shifter_pattern_hi[i] = _this.sprite_shifter_pattern_hi[i] << 1 & 0xFF;\n            }\n          }\n        }\n      }; // All but 1 of the secanlines is visible to the user. The pre-render scanline\n      // at -1, is used to configure the \"shifters\" for the first visible scanline, 0.\n\n\n      if (this.scanline >= -1 && this.scanline < 240) {\n        // Background Rendering ======================================================\n        if (this.scanline === 0 && this.cycle === 0) {\n          // \"Odd Frame\" cycle skip\n          this.cycle = 1;\n        }\n\n        if (this.scanline === -1 && this.cycle === 1) {\n          // Effectively start of new frame, so clear vertical blank flag\n          this.status.vertical_blank = 0; // Clear sprite overflow flag\n\n          this.status.sprite_overflow = 0; // Clear the sprite zero hit flag\n\n          this.status.sprite_zero_hit = 0; // Clear Shifters\n\n          for (var i = 0; i < 8; i++) {\n            this.sprite_shifter_pattern_lo[i] = 0;\n            this.sprite_shifter_pattern_hi[i] = 0;\n          }\n        }\n\n        if (this.cycle >= 2 && this.cycle < 258 || this.cycle >= 321 && this.cycle < 338) {\n          UpdateShifters(); // In these cycles we are collecting and working with visible data\n          // The \"shifters\" have been preloaded by the end of the previous\n          // scanline with the data for the start of this scanline. Once we\n          // leave the visible region, we go dormant until the shifters are\n          // preloaded for the next scanline.\n          // Fortunately, for background rendering, we go through a fairly\n          // repeatable sequence of events, every 2 clock cycles.\n\n          switch ((this.cycle - 1) % 8) {\n            case 0:\n              // Load the current background tile pattern and attributes into the \"shifter\"\n              LoadBackgroundShifters(); // Fetch the next background tile ID\n              // \"(vram_addr.reg & 0x0FFF)\" : Mask to 12 bits that are relevant\n              // \"| 0x2000\"                 : Offset into nametable space on PPU address bus\n\n              this.bg_next_tile_id = this.ppuRead(0x2000 | this.vram_addr.reg & 0x0FFF); // Explanation:\n              // The bottom 12 bits of the loopy register provide an index into\n              // the 4 nametables, regardless of nametable mirroring configuration.\n              // nametable_y(1) nametable_x(1) coarse_y(5) coarse_x(5)\n              //\n              // Consider a single nametable is a 32x32 array, and we have four of them\n              //   0                1\n              // 0 +----------------+----------------+\n              //   |                |                |\n              //   |                |                |\n              //   |    (32x32)     |    (32x32)     |\n              //   |                |                |\n              //   |                |                |\n              // 1 +----------------+----------------+\n              //   |                |                |\n              //   |                |                |\n              //   |    (32x32)     |    (32x32)     |\n              //   |                |                |\n              //   |                |                |\n              //   +----------------+----------------+\n              //\n              // This means there are 4096 potential locations in this array, which\n              // just so happens to be 2^12!\n\n              break;\n\n            case 2:\n              // Fetch the next background tile attribute. OK, so this one is a bit\n              // more involved :P\n              // Recall that each nametable has two rows of cells that are not tile\n              // information, instead they represent the attribute information that\n              // indicates which palettes are applied to which area on the screen.\n              // Importantly (and frustratingly) there is not a 1 to 1 correspondance\n              // between background tile and palette. Two rows of tile data holds\n              // 64 attributes. Therfore we can assume that the attributes affect\n              // 8x8 zones on the screen for that nametable. Given a working resolution\n              // of 256x240, we can further assume that each zone is 32x32 pixels\n              // in screen space, or 4x4 tiles. Four system palettes are allocated\n              // to background rendering, so a palette can be specified using just\n              // 2 bits. The attribute byte therefore can specify 4 distinct palettes.\n              // Therefore we can even further assume that a single palette is\n              // applied to a 2x2 tile combination of the 4x4 tile zone. The very fact\n              // that background tiles \"share\" a palette locally is the reason why\n              // in some games you see distortion in the colours at screen edges.\n              // As before when choosing the tile ID, we can use the bottom 12 bits of\n              // the loopy register, but we need to make the implementation \"coarser\"\n              // because instead of a specific tile, we want the attribute byte for a\n              // group of 4x4 tiles, or in other words, we divide our 32x32 address\n              // by 4 to give us an equivalent 8x8 address, and we offset this address\n              // into the attribute section of the target nametable.\n              // Reconstruct the 12 bit loopy address into an offset into the\n              // attribute memory\n              // \"(vram_addr.coarse_x >> 2)\"        : integer divide coarse x by 4,\n              //                                      from 5 bits to 3 bits\n              // \"((vram_addr.coarse_y >> 2) << 3)\" : integer divide coarse y by 4,\n              //                                      from 5 bits to 3 bits,\n              //                                      shift to make room for coarse x\n              // Result so far: YX00 00yy yxxx\n              // All attribute memory begins at 0x03C0 within a nametable, so OR with\n              // result to select target nametable, and attribute byte offset. Finally\n              // OR with 0x2000 to offset into nametable address space on PPU bus.\n              this.bg_next_tile_attrib = this.ppuRead(0x23C0 | this.vram_addr.nametable_y << 11 | this.vram_addr.nametable_x << 10 | this.vram_addr.coarse_y >> 2 << 3 | this.vram_addr.coarse_x >> 2); // Right we've read the correct attribute byte for a specified address,\n              // but the byte itself is broken down further into the 2x2 tile groups\n              // in the 4x4 attribute zone.\n              // The attribute byte is assembled thus: BR(76) BL(54) TR(32) TL(10)\n              //\n              // +----+----+\t\t\t    +----+----+\n              // | TL | TR |\t\t\t    | ID | ID |\n              // +----+----+ where TL =   +----+----+\n              // | BL | BR |\t\t\t    | ID | ID |\n              // +----+----+\t\t\t    +----+----+\n              //\n              // Since we know we can access a tile directly from the 12 bit address, we\n              // can analyse the bottom bits of the coarse coordinates to provide us with\n              // the correct offset into the 8-bit word, to yield the 2 bits we are\n              // actually interested in which specifies the palette for the 2x2 group of\n              // tiles. We know if \"coarse y % 4\" < 2 we are in the top half else bottom half.\n              // Likewise if \"coarse x % 4\" < 2 we are in the left half else right half.\n              // Ultimately we want the bottom two bits of our attribute word to be the\n              // palette selected. So shift as required...\n\n              /* if (this.vram_addr.coarse_y % 4 < 2) this.bg_next_tile_attrib >>= 4;\n              \tif (this.vram_addr.coarse_x % 4 < 2) this.bg_next_tile_attrib >>= 2; */\n\n              if (this.vram_addr.coarse_y & 0x02) this.bg_next_tile_attrib >>= 4;\n              if (this.vram_addr.coarse_x & 0x02) this.bg_next_tile_attrib >>= 2;\n              this.bg_next_tile_attrib &= 0x03;\n              break;\n            // Compared to the last two, the next two are the easy ones... :P\n\n            case 4:\n              // Fetch the next background tile LSB bit plane from the pattern memory\n              // The Tile ID has been read from the nametable. We will use this id to\n              // index into the pattern memory to find the correct sprite (assuming\n              // the sprites lie on 8x8 pixel boundaries in that memory, which they do\n              // even though 8x16 sprites exist, as background tiles are always 8x8).\n              //\n              // Since the sprites are effectively 1 bit deep, but 8 pixels wide, we\n              // can represent a whole sprite row as a single byte, so offsetting\n              // into the pattern memory is easy. In total there is 8KB so we need a\n              // 13 bit address.\n              // \"(control.pattern_background << 12)\"  : the pattern memory selector\n              //                                         from control register, either 0K\n              //                                         or 4K offset\n              // \"((uint16_t)bg_next_tile_id << 4)\"    : the tile id multiplied by 16, as\n              //                                         2 lots of 8 rows of 8 bit pixels\n              // \"(vram_addr.fine_y)\"                  : Offset into which row based on\n              //                                         vertical scroll offset\n              // \"+ 0\"                                 : Mental clarity for plane offset\n              // Note: No PPU address bus offset required as it starts at 0x0000\n              this.bg_next_tile_lsb = this.ppuRead((this.control.pattern_background << 12) + (this.bg_next_tile_id << 4) + this.vram_addr.fine_y + 0);\n              break;\n\n            case 6:\n              // Fetch the next background tile MSB bit plane from the pattern memory\n              // This is the same as above, but has a +8 offset to select the next bit plane\n              this.bg_next_tile_msb = this.ppuRead((this.control.pattern_background << 12) + (this.bg_next_tile_id << 4) + this.vram_addr.fine_y + 8);\n              break;\n\n            case 7:\n              // Increment the background tile \"pointer\" to the next tile horizontally\n              // in the nametable memory. Note this may cross nametable boundaries which\n              // is a little complex, but essential to implement scrolling\n              IncrementScrollX();\n              break;\n          }\n        } // End of a visible scanline, so increment downwards...\n\n\n        if (this.cycle === 256) {\n          IncrementScrollY();\n        } //...and reset the x position\n\n\n        if (this.cycle === 257) {\n          LoadBackgroundShifters();\n          TransferAddressX();\n        } // Superfluous reads of tile id at end of scanline\n\n\n        if (this.cycle === 338 || this.cycle === 340) {\n          this.bg_next_tile_id = this.ppuRead(0x2000 | this.vram_addr.reg & 0x0FFF);\n        }\n\n        if (this.scanline === -1 && this.cycle >= 280 && this.cycle < 305) {\n          // End of vertical blank period so reset the Y address ready for rendering\n          TransferAddressY();\n        } // Foreground Rendering ========================================================\n        // I'm gonna cheat a bit here, which may reduce compatibility, but greatly\n        // simplifies delivering an intuitive understanding of what exactly is going\n        // on. The PPU loads sprite information successively during the region that\n        // background tiles are not being drawn. Instead, I'm going to perform\n        // all sprite evaluation in one hit. THE NES DOES NOT DO IT LIKE THIS! This makes\n        // it easier to see the process of sprite evaluation.\n\n\n        if (this.cycle === 257 && this.scanline >= 0) {\n          // We've reached the end of a visible scanline. It is now time to determine\n          // which sprites are visible on the next scanline, and preload this info\n          // into buffers that we can work with while the scanline scans the row.\n          // Firstly, clear out the sprite memory. This memory is used to store the\n          // sprites to be rendered. It is not the OAM.\n          // @TODO std::memset(spriteScanline, 0xFF, 8 * sizeof(sObjectAttributeEntry));\n          for (var _i2 = 0; _i2 < 8; _i2++) {\n            this.spriteScanline[_i2] = {};\n          } // The NES supports a maximum number of sprites per scanline. Nominally\n          // this is 8 or fewer sprites. This is why in some games you see sprites\n          // flicker or disappear when the scene gets busy.\n\n\n          this.sprite_count = 0; // Secondly, clear out any residual information in sprite pattern shifters\n\n          for (var _i3 = 0; _i3 < 8; _i3++) {\n            this.sprite_shifter_pattern_lo[_i3] = 0;\n            this.sprite_shifter_pattern_hi[_i3] = 0;\n          } // Thirdly, Evaluate which sprites are visible in the next scanline. We need\n          // to iterate through the OAM until we have found 8 sprites that have Y-positions\n          // and heights that are within vertical range of the next scanline. Once we have\n          // found 8 or exhausted the OAM we stop. Now, notice I count to 9 sprites. This\n          // is so I can set the sprite overflow flag in the event of there being > 8 sprites.\n\n\n          var nOAMEntry = 0; // New set of sprites. Sprite zero may not exist in the new set, so clear this\n          // flag.\n\n          this.bSpriteZeroHitPossible = false;\n\n          while (nOAMEntry < 64 && this.sprite_count < 9) {\n            // Note the conversion to signed numbers here\n            var diff = this.scanline - this.OAM[nOAMEntry].y; // If the difference is positive then the scanline is at least at the\n            // same height as the sprite, so check if it resides in the sprite vertically\n            // depending on the current \"sprite height mode\"\n            // FLAGGED\n\n            if (diff >= 0 && diff < (this.control.sprite_size ? 16 : 8)) {\n              // Sprite is visible, so copy the attribute entry over to our\n              // scanline sprite cache. Ive added < 8 here to guard the array\n              // being written to.\n              if (this.sprite_count < 8) {\n                // Is this sprite sprite zero?\n                if (nOAMEntry === 0) {\n                  // It is, so its possible it may trigger a\n                  // sprite zero hit when drawn\n                  this.bSpriteZeroHitPossible = true;\n                } // @TODO memcpy(spriteScanline[sprite_count], OAM[nOAMEntry], sizeof(sObjectAttributeEntry));\n\n\n                this.spriteScanline[this.sprite_count] = _objectSpread({}, this.OAM[nOAMEntry]);\n                this.sprite_count++;\n              }\n            }\n\n            nOAMEntry++;\n          } // End of sprite evaluation for next scanline\n          // Set sprite overflow flag\n\n\n          this.status.sprite_overflow = this.sprite_count > 8 ? 1 : 0; // Now we have an array of the 8 visible sprites for the next scanline. By\n          // the nature of this search, they are also ranked in priority, because\n          // those lower down in the OAM have the higher priority.\n          // We also guarantee that \"Sprite Zero\" will exist in spriteScanline[0] if\n          // it is evaluated to be visible.\n        }\n\n        if (this.cycle === 340) {\n          // Now we're at the very end of the scanline, I'm going to prepare the\n          // sprite shifters with the 8 or less selected sprites.\n          for (var _i4 = 0; _i4 < this.sprite_count; _i4++) {\n            // We need to extract the 8-bit row patterns of the sprite with the\n            // correct vertical offset. The \"Sprite Mode\" also affects this as\n            // the sprites may be 8 or 16 rows high. Additionally, the sprite\n            // can be flipped both vertically and horizontally. So there's a lot\n            // going on here :P\n            var sprite_pattern_bits_lo = void 0,\n                sprite_pattern_bits_hi = void 0;\n            var sprite_pattern_addr_lo = void 0,\n                sprite_pattern_addr_hi = void 0; // Determine the memory addresses that contain the byte of pattern data. We\n            // only need the lo pattern address, because the hi pattern address is always\n            // offset by 8 from the lo address.\n\n            if (!this.control.sprite_size) {\n              // 8x8 Sprite Mode - The control register determines the pattern table\n              if (!(this.spriteScanline[_i4].attribute & 0x80)) {\n                // Sprite is NOT flipped vertically, i.e. normal\n                sprite_pattern_addr_lo = this.control.pattern_sprite << 12 | // Which Pattern Table? 0KB or 4KB offset\n                this.spriteScanline[_i4].id << 4 // Which Cell? Tile ID * 16 (16 bytes per tile)\n                | this.scanline - this.spriteScanline[_i4].y; // Which Row in cell? (0->7)\n              } else {\n                // Sprite is flipped vertically, i.e. upside down\n                sprite_pattern_addr_lo = this.control.pattern_sprite << 12 | // Which Pattern Table? 0KB or 4KB offset\n                this.spriteScanline[_i4].id << 4 // Which Cell? Tile ID * 16 (16 bytes per tile)\n                | 7 - (this.scanline - this.spriteScanline[_i4].y); // Which Row in cell? (7->0)\n              }\n            } else {\n              // 8x16 Sprite Mode - The sprite attribute determines the pattern table\n              if (!(this.spriteScanline[_i4].attribute & 0x80)) {\n                // Sprite is NOT flipped vertically, i.e. normal\n                if (this.scanline - this.spriteScanline[_i4].y < 8) {\n                  // Reading Top half Tile\n                  sprite_pattern_addr_lo = (this.spriteScanline[_i4].id & 0x01) << 12 | // Which Pattern Table? 0KB or 4KB offset\n                  (this.spriteScanline[_i4].id & 0xFE) << 4 // Which Cell? Tile ID * 16 (16 bytes per tile)\n                  | this.scanline - this.spriteScanline[_i4].y & 0x07; // Which Row in cell? (0->7)\n                } else {\n                  // Reading Bottom Half Tile\n                  sprite_pattern_addr_lo = (this.spriteScanline[_i4].id & 0x01) << 12 | // Which Pattern Table? 0KB or 4KB offset\n                  (this.spriteScanline[_i4].id & 0xFE) + 1 << 4 // Which Cell? Tile ID * 16 (16 bytes per tile)\n                  | this.scanline - this.spriteScanline[_i4].y & 0x07; // Which Row in cell? (0->7)\n                }\n              } else {\n                // Sprite is flipped vertically, i.e. upside down\n                if (this.scanline - this.spriteScanline[_i4].y < 8) {\n                  // Reading Top half Tile\n                  sprite_pattern_addr_lo = (this.spriteScanline[_i4].id & 0x01) << 12 | // Which Pattern Table? 0KB or 4KB offset\n                  (this.spriteScanline[_i4].id & 0xFE) + 1 << 4 // Which Cell? Tile ID * 16 (16 bytes per tile)\n                  | 7 - (this.scanline - this.spriteScanline[_i4].y) & 0x07; // Which Row in cell? (0->7)\n                } else {\n                  // Reading Bottom Half Tile\n                  sprite_pattern_addr_lo = (this.spriteScanline[_i4].id & 0x01) << 12 | // Which Pattern Table? 0KB or 4KB offset\n                  (this.spriteScanline[_i4].id & 0xFE) << 4 // Which Cell? Tile ID * 16 (16 bytes per tile)\n                  | 7 - (this.scanline - this.spriteScanline[_i4].y) & 0x07; // Which Row in cell? (0->7)\n                }\n              }\n            } // Phew... XD I'm absolutely certain you can use some fantastic bit\n            // manipulation to reduce all of that to a few one liners, but in this\n            // form it's easy to see the processes required for the different\n            // sizes and vertical orientations\n            // Hi bit plane equivalent is always offset by 8 bytes from lo bit plane\n\n\n            sprite_pattern_addr_hi = sprite_pattern_addr_lo + 8; // Now we have the address of the sprite patterns, we can read them\n\n            sprite_pattern_bits_lo = this.ppuRead(sprite_pattern_addr_lo);\n            sprite_pattern_bits_hi = this.ppuRead(sprite_pattern_addr_hi); // If the sprite is flipped horizontally, we need to flip the\n            // pattern bytes.\n\n            if (this.spriteScanline[_i4].attribute & 0x40) {\n              // This little lambda function \"flips\" a byte\n              // so 0b11100000 becomes 0b00000111. It's very\n              // clever, and stolen completely from here:\n              // https://stackoverflow.com/a/2602885\n              var flipbyte = function flipbyte(b) {\n                b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;\n                b = (b & 0xCC) >> 2 | (b & 0x33) << 2;\n                b = (b & 0xAA) >> 1 | (b & 0x55) << 1;\n                return b;\n              }; // Flip Patterns Horizontally\n\n\n              sprite_pattern_bits_lo = flipbyte(sprite_pattern_bits_lo);\n              sprite_pattern_bits_hi = flipbyte(sprite_pattern_bits_hi);\n            } // Finally! We can load the pattern into our sprite shift registers\n            // ready for rendering on the next scanline\n\n\n            this.sprite_shifter_pattern_lo[_i4] = sprite_pattern_bits_lo;\n            this.sprite_shifter_pattern_hi[_i4] = sprite_pattern_bits_hi;\n          }\n        }\n      }\n\n      if (this.scanline === 240) {// Post Render Scanline - Do Nothing!\n      }\n\n      if (this.scanline >= 241 && this.scanline < 261) {\n        if (this.scanline === 241 && this.cycle === 1) {\n          // Effectively end of frame, so set vertical blank flag\n          this.status.vertical_blank = 1; // If the control register tells us to emit a NMI when\n          // entering vertical blanking period, do it! The CPU\n          // will be informed that rendering is complete so it can\n          // perform operations with the PPU knowing it wont\n          // produce visible artefacts\n\n          if (this.control.enable_nmi) this.nmi = true;\n        }\n      } // Composition - We now have background & foreground pixel information for this cycle\n      // Background =============================================================\n\n\n      var bg_pixel = 0x00; // The 2-bit pixel to be rendered\n\n      var bg_palette = 0x00; // The 3-bit index of the palette the pixel indexes\n      // We only render backgrounds if the PPU is enabled to do so. Note if\n      // background rendering is disabled, the pixel and palette combine\n      // to form 0x00. This will fall through the colour tables to yield\n      // the current background colour in effect\n\n      if (this.mask.render_background) {\n        // Handle Pixel Selection by selecting the relevant bit\n        // depending upon fine x scolling. This has the effect of\n        // offsetting ALL background rendering by a set number\n        // of pixels, permitting smooth scrolling\n        var bit_mux = 0x8000 >> this.fine_x; // Select Plane pixels by extracting from the shifter\n        // at the required location.\n\n        var p0_pixel = (this.bg_shifter_pattern_lo & bit_mux) > 0 ? 1 : 0;\n        var p1_pixel = (this.bg_shifter_pattern_hi & bit_mux) > 0 ? 1 : 0; // Combine to form pixel index\n\n        bg_pixel = p1_pixel << 1 | p0_pixel; // Get palette\n\n        var bg_pal0 = (this.bg_shifter_attrib_lo & bit_mux) > 0 ? 1 : 0;\n        var bg_pal1 = (this.bg_shifter_attrib_hi & bit_mux) > 0 ? 1 : 0;\n        bg_palette = bg_pal1 << 1 | bg_pal0;\n      } // Foreground =============================================================\n\n\n      var fg_pixel = 0x00; // The 2-bit pixel to be rendered\n\n      var fg_palette = 0x00; // The 3-bit index of the palette the pixel indexes\n\n      var fg_priority = 0x00; // A bit of the sprite attribute indicates if its\n      // more important than the background\n\n      if (this.mask.render_sprites) {\n        // Iterate through all sprites for this scanline. This is to maintain\n        // sprite priority. As soon as we find a non transparent pixel of\n        // a sprite we can abort\n        this.bSpriteZeroBeingRendered = false;\n\n        for (var _i5 = 0; _i5 < this.sprite_count; _i5++) {\n          // Scanline cycle has \"collided\" with sprite, shifters taking over\n          if (this.spriteScanline[_i5].x === 0) {\n            // Note Fine X scrolling does not apply to sprites, the game\n            // should maintain their relationship with the background. So\n            // we'll just use the MSB of the shifter\n            // Determine the pixel value...\n            var fg_pixel_lo = (this.sprite_shifter_pattern_lo[_i5] & 0x80) > 0;\n            var fg_pixel_hi = (this.sprite_shifter_pattern_hi[_i5] & 0x80) > 0;\n            fg_pixel = fg_pixel_hi << 1 | fg_pixel_lo; // Extract the palette from the bottom two bits. Recall\n            // that foreground palettes are the latter 4 in the\n            // palette memory.\n\n            fg_palette = (this.spriteScanline[_i5].attribute & 0x03) + 0x04;\n            fg_priority = (this.spriteScanline[_i5].attribute & 0x20) === 0; // If pixel is not transparent, we render it, and dont\n            // bother checking the rest because the earlier sprites\n            // in the list are higher priority\n\n            if (fg_pixel !== 0) {\n              if (_i5 === 0) // Is this sprite zero?\n                {\n                  this.bSpriteZeroBeingRendered = true;\n                }\n\n              break;\n            }\n          }\n        }\n      } // Now we have a background pixel and a foreground pixel. They need\n      // to be combined. It is possible for sprites to go behind background\n      // tiles that are not \"transparent\", yet another neat trick of the PPU\n      // that adds complexity for us poor emulator developers...\n\n\n      var pixel = 0x00; // The FINAL Pixel...\n\n      var palette = 0x00; // The FINAL Palette...\n\n      if (bg_pixel === 0 && fg_pixel === 0) {\n        // The background pixel is transparent\n        // The foreground pixel is transparent\n        // No winner, draw \"background\" colour\n        pixel = 0x00;\n        palette = 0x00;\n      } else if (bg_pixel === 0 && fg_pixel > 0) {\n        // The background pixel is transparent\n        // The foreground pixel is visible\n        // Foreground wins!\n        pixel = fg_pixel;\n        palette = fg_palette;\n      } else if (bg_pixel > 0 && fg_pixel === 0) {\n        // The background pixel is visible\n        // The foreground pixel is transparent\n        // Background wins!\n        pixel = bg_pixel;\n        palette = bg_palette;\n      } else if (bg_pixel > 0 && fg_pixel > 0) {\n        // The background pixel is visible\n        // The foreground pixel is visible\n        // Hmmm...\n        if (fg_priority) {\n          // Foreground cheats its way to victory!\n          pixel = fg_pixel;\n          palette = fg_palette;\n        } else {\n          // Background is considered more important!\n          pixel = bg_pixel;\n          palette = bg_palette;\n        } // Sprite Zero Hit detection\n\n\n        if (this.bSpriteZeroHitPossible && this.bSpriteZeroBeingRendered) {\n          // Sprite zero is a collision between foreground and background\n          // so they must both be enabled\n          if (this.mask.render_background & this.mask.render_sprites) {\n            // The left edge of the screen has specific switches to control\n            // its appearance. This is used to smooth inconsistencies when\n            // scrolling (since sprites x coord must be >= 0)\n            if (~(this.mask.render_background_left | this.mask.render_sprites_left)) {\n              if (this.cycle >= 9 && this.cycle < 258) {\n                this.status.sprite_zero_hit = 1;\n              }\n            } else {\n              if (this.cycle >= 1 && this.cycle < 258) {\n                this.status.sprite_zero_hit = 1;\n              }\n            }\n          }\n        }\n      } // Now we have a final pixel colour, and a palette for this cycle\n      // of the current scanline. Let's at long last, draw that ^&%*er :P\n\n\n      var color = this.GetColourFromPaletteRam(palette, pixel); //let color = this.GetColourFromPaletteRam(bg_palette, bg_pixel).getCode();\n\n      this.sprScreen.SetPixel(this.cycle - 1, this.scanline, color); // Advance renderer - it never stops, it's relentless\n\n      this.cycle++;\n\n      if (this.cycle >= 341) {\n        this.cycle = 0;\n        this.scanline++;\n\n        if (this.scanline >= 261) {\n          this.scanline = -1;\n          this.frame_complete = true;\n        }\n      }\n    }\n  }]);\n\n  return olc2C02;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (olc2C02);\n\n//# sourceURL=webpack:///./src/olc2C02.js?");

/***/ })

/******/ });